diff --git a/product-mini/platforms/teaclave/CMakeLists.txt b/product-mini/platforms/teaclave/CMakeLists.txt
new file mode 100644
index 0000000..01451de
--- /dev/null
+++ b/product-mini/platforms/teaclave/CMakeLists.txt
@@ -0,0 +1,103 @@
+cmake_minimum_required (VERSION 2.8)
+
+project(minimal)
+
+set (WAMR_BUILD_PLATFORM "teaclave")
+
+# Reset default linker flags
+set (CMAKE_SHARED_LIBRARY_LINK_C_FLAGS "")
+set (CMAKE_SHARED_LIBRARY_LINK_CXX_FLAGS "")
+
+# Steal from linux-sgx platform CMake file
+# Set WAMR_BUILD_TARGET
+if (NOT DEFINED WAMR_BUILD_TARGET)
+  if (CMAKE_SIZEOF_VOID_P EQUAL 8)
+    # Build as X86_64 by default in 64-bit platform
+    set (WAMR_BUILD_TARGET "X86_64")
+  else ()
+    # Build as X86_32 by default in 32-bit platform
+    set (WAMR_BUILD_TARGET "X86_32")
+  endif ()
+endif ()
+
+if (NOT CMAKE_BUILD_TYPE)
+  set(CMAKE_BUILD_TYPE Release)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_INTERP)
+  # Enable Interpreter by default
+  set (WAMR_BUILD_INTERP 1)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_AOT)
+  # Enable AOT by default
+  # Please install Intel SGX SDKv2.8 or later.
+  set (WAMR_BUILD_AOT 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_JIT)
+  # Disable JIT by default.
+  set (WAMR_BUILD_JIT 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_LIBC_BUILTIN)
+  # Enable libc builtin support by default
+  # Changed to 0 here
+  set (WAMR_BUILD_LIBC_BUILTIN 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_LIBC_WASI)
+  # Enable libc wasi support by default
+  set (WAMR_BUILD_LIBC_WASI 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_FAST_INTERP)
+  # Enable fast interpreter
+  set (WAMR_BUILD_FAST_INTERP 1)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_MULTI_MODULE)
+  # Enable multiple modules
+  set (WAMR_BUILD_MULTI_MODULE 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_MINI_LOADER)
+  # Disable wasm mini loader by default
+  set (WAMR_BUILD_MINI_LOADER 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_SIMD)
+  # Enable SIMD by default
+  set (WAMR_BUILD_SIMD 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_REF_TYPES)
+  # Disable reference types by default
+  set (WAMR_BUILD_REF_TYPES 0)
+endif ()
+
+
+set (WAMR_BUILD_LIB_PTHREAD 0)
+
+# disabled for now, unsafe
+set (WAMR_DISABLE_HW_BOUND_CHECK 1)
+
+# nullify printf
+# set (BH_VPRINTF null)
+
+set (WAMR_ROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../..)
+
+include (${WAMR_ROOT_DIR}/build-scripts/runtime_lib.cmake)
+add_library(vmlib ${WAMR_RUNTIME_LIB_SOURCE})
+
+set (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,--gc-sections -pie -fPIE")
+
+set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -Wformat -Wformat-security")
+
+include (${SHARED_DIR}/utils/uncommon/shared_uncommon.cmake)
+
+add_executable (minimal main.c ${UNCOMMON_SHARED_SOURCE})
+
+# install (TARGETS minimal DESTINATION bin)
+
+target_link_libraries (minimal vmlib ${LLVM_AVAILABLE_LIBS} ${UV_A_LIBS} -lm -ldl -lpthread)
\ No newline at end of file
diff --git a/product-mini/platforms/teaclave/main.c b/product-mini/platforms/teaclave/main.c
new file mode 100644
index 0000000..94cb73a
--- /dev/null
+++ b/product-mini/platforms/teaclave/main.c
@@ -0,0 +1,135 @@
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include "wasm_export.h"
+#include <fcntl.h>
+
+// steal from `bh_read_file_to_buffer`
+
+char*
+read_file_to_buffer(const char *filename, int *ret_size)
+{
+    char *buffer;
+    int file;
+    int file_size, buf_size, read_size;
+    struct stat stat_buf;
+
+    if (!filename || !ret_size) {
+        printf("Read file to buffer failed: invalid filename or ret size.\n");
+        return NULL;
+    }
+
+    if ((file = open(filename, O_RDONLY, 0)) == -1) {
+        printf("Read file to buffer failed: open file %s failed.\n",
+               filename);
+        return NULL;
+    }
+
+    if (fstat(file, &stat_buf) != 0) {
+        printf("Read file to buffer failed: fstat file %s failed.\n",
+               filename);
+        close(file);
+        return NULL;
+    }
+
+    file_size = (int)stat_buf.st_size;
+
+    /* At lease alloc 1 byte to avoid malloc failed */
+    buf_size = file_size > 0 ? file_size : 1;
+
+    if (!(buffer = malloc(buf_size))) {
+        printf("Read file to buffer failed: alloc memory failed.\n");
+        close(file);
+        return NULL;
+    }
+#if WASM_ENABLE_MEMORY_TRACING != 0
+    printf("Read file, total size: %u\n", file_size);
+#endif
+
+    read_size = (int)read(file, buffer, file_size);
+    close(file);
+
+    if (read_size < file_size) {
+        printf("Read file to buffer failed: read file content failed.\n");
+        BH_FREE(buffer);
+        return NULL;
+    }
+
+    *ret_size = file_size;
+    return buffer;
+}
+
+int main(int argc, char const *argv[])
+{
+    // int should be uint32 in Rust!
+    char* file_buffer;
+    int file_size;
+    void* module;
+    void* module_instance;
+    char error_buffer[128];
+    int stack_size = 8092, heap_size = 8092;
+
+    for(int i = 0; i < argc; i++) {
+        printf("arg %d: %s\n", i, argv[i]);
+    }
+    /* initialize the wasm runtime by default configurations */
+    wasm_runtime_init();
+
+    /* read WASM file into a memory buffer */
+    file_buffer = read_file_to_buffer(argv[1], &file_size);
+    printf("buffer: %p\n", file_buffer);
+
+    // /* add line below if we want to export native functions to WASM app */
+    // wasm_runtime_register_natives(...);
+
+    /* parse the WASM file from buffer and create a WASM module */
+    module = (void*)wasm_runtime_load(file_buffer, file_size, error_buffer, sizeof(error_buffer));
+    printf("module: %p\n", module);
+
+    /* create an instance of the WASM module (WASM linear memory is ready) */
+    module_instance = (void*)wasm_runtime_instantiate(module, stack_size, heap_size, error_buffer, sizeof(error_buffer));
+    printf("module_instance: %p\n", module_instance);
+
+
+    // /*Call the main function of the WASM*/
+    // int wasm_argc = 2;
+    // char* wasm_argv[2] = {"2", "3"};
+    // printf("before exec: %d, %d, %s, %s\n", wasm_argv[0], wasm_argv[1], wasm_argv[0], wasm_argv[1]);
+    // int ret = (int)wasm_application_execute_main(module_instance, wasm_argc, wasm_argv);
+    // printf("after exec: %d, %d, %s, %s\n", wasm_argv[0], wasm_argv[1], wasm_argv[0], wasm_argv[1]);
+
+
+    int wasm_argc = 2;
+    int entry_argc = 2;
+    char* entry_argv[2] = {"2", "3"};
+
+    int enrty_argv_dup[entry_argc];
+
+    for (int i = 0; i < entry_argc; i ++) {
+        enrty_argv_dup[i] = wasm_runtime_module_dup_data(module_instance, entry_argv[i], strlen(entry_argv[i]));
+    }
+    int enrty_argv_addr = wasm_runtime_module_dup_data(module_instance, enrty_argv_dup, sizeof(enrty_argv_dup));
+
+    int wasm_argv[] = {entry_argc, enrty_argv_addr};
+
+    // lookup a WASM function by its name. 
+    // The function signature can NULL here
+    void* func = wasm_runtime_lookup_function(module_instance, "test", NULL);
+    printf("func: %p\n", func);
+
+    // creat a excution environment which can be used by executing WASM functions
+    void* exec_env = wasm_runtime_create_exec_env(module_instance, stack_size);
+    printf("exec_env: %p\n", exec_env);
+
+    if (wasm_runtime_call_wasm(exec_env, func, wasm_argc, wasm_argv) ) {
+        /* the return value is stored in argv[0] */
+        printf("test function return: %d\n", wasm_argv[0]);
+    }
+    else {
+        printf("%s\n", wasm_runtime_get_exception(module_instance));
+    }
+
+
+}
+
