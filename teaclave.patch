diff --git a/core/shared/platform/common/posix/posix_thread.c b/core/shared/platform/common/posix/posix_thread.c
index 60a13fb..ce0b8ad 100644
--- a/core/shared/platform/common/posix/posix_thread.c
+++ b/core/shared/platform/common/posix/posix_thread.c
@@ -544,4 +544,3 @@ os_sigreturn()
 #endif
 }
 #endif /* end of OS_ENABLE_HW_BOUND_CHECK */
-
diff --git a/core/shared/platform/teaclave/platform_internal.h b/core/shared/platform/teaclave/platform_internal.h
new file mode 100644
index 0000000..83a08f4
--- /dev/null
+++ b/core/shared/platform/teaclave/platform_internal.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2019 Intel Corporation.  All rights reserved.
+ * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+ */
+
+#ifndef _PLATFORM_INTERNAL_H
+#define _PLATFORM_INTERNAL_H
+
+#include <inttypes.h>
+#include <stdbool.h>
+#include <assert.h>
+#include <time.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <stdarg.h>
+#include <ctype.h>
+#include <pthread.h>
+#include <signal.h>
+#include <semaphore.h>
+#include <limits.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <poll.h>
+#include <sched.h>
+#include <errno.h>
+#include <netinet/in.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+#include <sys/timeb.h>
+#include <sys/uio.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/resource.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef BH_PLATFORM_TEACLAVE
+#define BH_PLATFORM_TEACLAVE
+#endif
+
+/* Stack size of applet threads's native part.  */
+#define BH_APPLET_PRESERVED_STACK_SIZE (32 * 1024)
+
+/* Default thread priority */
+#define BH_THREAD_DEFAULT_PRIORITY 0
+// #define os_thread_get_stack_boundary null
+
+typedef pthread_t korp_tid;
+typedef pthread_mutex_t korp_mutex;
+typedef pthread_cond_t korp_cond;
+typedef pthread_t korp_thread;
+
+#define os_thread_local_attribute __thread
+
+#if WASM_DISABLE_HW_BOUND_CHECK == 0
+#if defined(BUILD_TARGET_X86_64) \
+    || defined(BUILD_TARGET_AMD_64) \
+    || defined(BUILD_TARGET_AARCH64)
+
+#include <setjmp.h>
+
+#define OS_ENABLE_HW_BOUND_CHECK
+
+typedef jmp_buf korp_jmpbuf;
+
+#define os_setjmp setjmp
+#define os_longjmp longjmp
+#define os_alloca alloca
+
+#define os_getpagesize getpagesize
+
+typedef void (*os_signal_handler)(void *sig_addr);
+
+int os_thread_signal_init(os_signal_handler handler);
+
+void os_thread_signal_destroy();
+
+bool os_thread_signal_inited();
+
+void os_signal_unmask();
+
+void os_sigreturn();
+#endif /* end of BUILD_TARGET_X86_64/AMD_64/AARCH64 */
+#endif /* end of WASM_DISABLE_HW_BOUND_CHECK */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of _PLATFORM_INTERNAL_H */
+
diff --git a/core/shared/platform/teaclave/shared_platform.cmake b/core/shared/platform/teaclave/shared_platform.cmake
new file mode 100644
index 0000000..0b8e32a
--- /dev/null
+++ b/core/shared/platform/teaclave/shared_platform.cmake
@@ -0,0 +1,16 @@
+# Copyright (C) 2019 Intel Corporation.  All rights reserved.
+# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+
+set (PLATFORM_SHARED_DIR ${CMAKE_CURRENT_LIST_DIR})
+
+add_definitions(-DBH_PLATFORM_TEACLAVE)
+
+include_directories(${PLATFORM_SHARED_DIR})
+include_directories(${PLATFORM_SHARED_DIR}/../include)
+
+file (GLOB_RECURSE source_all ${PLATFORM_SHARED_DIR}/*.c)
+
+set (PLATFORM_SHARED_SOURCE ${source_all} ${PLATFORM_COMMON_POSIX_SOURCE})
+
+file (GLOB header ${PLATFORM_SHARED_DIR}/../include/*.h)
+LIST (APPEND RUNTIME_LIB_HEADER_LIST ${header})
diff --git a/core/shared/platform/teaclave/teaclave_platform.c b/core/shared/platform/teaclave/teaclave_platform.c
new file mode 100644
index 0000000..297c862
--- /dev/null
+++ b/core/shared/platform/teaclave/teaclave_platform.c
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2019 Intel Corporation.  All rights reserved.
+ * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+ */
+
+#include "platform_api_vmcore.h"
+#include <platform_api_vmcore.h>
+#include <platform_api_extension.h>
+
+int
+bh_platform_init()
+{
+    return 0;
+}
+
+void
+bh_platform_destroy()
+{
+}
+
+int
+os_printf(const char *format, ...)
+{
+    int ret = 0;
+    va_list ap;
+
+    va_start(ap, format);
+#ifndef BH_VPRINTF
+    // ya0guang: also nullify here
+    return NULL;
+    // ret += vprintf(format, ap);
+#else
+    ret += BH_VPRINTF(format, ap);
+#endif
+    va_end(ap);
+
+    return ret;
+}
+
+int
+os_vprintf(const char *format, va_list ap)
+{
+#ifndef BH_VPRINTF
+    // ya0guang: nullify printf
+    return 0;
+    // return vprintf(format, ap);
+#else
+    return BH_VPRINTF(format, ap);
+#endif
+}
+
+// ya0guang: nullify this implementation 
+uint8 *os_thread_get_stack_boundary(void)
+{
+    return NULL;
+}
+
+// functions below are copied from the common library
+
+void *
+os_malloc(unsigned size)
+{
+    return malloc(size);
+}
+
+void *
+os_realloc(void *ptr, unsigned size)
+{
+    return realloc(ptr, size);
+}
+
+void
+os_free(void *ptr)
+{
+    free(ptr);
+}
+
+int os_mutex_destroy(korp_mutex *mutex)
+{
+    int ret;
+
+    assert(mutex);
+    ret = pthread_mutex_destroy(mutex);
+
+    return ret == 0 ? BHT_OK : BHT_ERROR;
+}
+
+
+int os_mutex_unlock(korp_mutex *mutex)
+{
+    int ret;
+
+    assert(mutex);
+    ret = pthread_mutex_unlock(mutex);
+
+    return ret == 0 ? BHT_OK : BHT_ERROR;
+}
+
+int os_mutex_lock(korp_mutex *mutex)
+{
+    int ret;
+
+    assert(mutex);
+    ret = pthread_mutex_lock(mutex);
+
+    return ret == 0 ? BHT_OK : BHT_ERROR;
+}
+
+int os_mutex_init(korp_mutex *mutex)
+{
+    return pthread_mutex_init(mutex, NULL) == 0 ? BHT_OK : BHT_ERROR;
+}
+
+uint64
+os_time_get_boot_microsecond()
+{
+    struct timespec ts;
+    if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0) {
+        return 0;
+    }
+
+    return ((uint64) ts.tv_sec) * 1000 * 1000 + ((uint64)ts.tv_nsec) / 1000;
+}
+
+
+korp_tid os_self_thread()
+{
+    return (korp_tid) pthread_self();
+}
\ No newline at end of file
diff --git a/product-mini/platforms/linux-sgx/enclave-sample/App/App.o b/product-mini/platforms/linux-sgx/enclave-sample/App/App.o
new file mode 100644
index 0000000..2476212
Binary files /dev/null and b/product-mini/platforms/linux-sgx/enclave-sample/App/App.o differ
diff --git a/product-mini/platforms/linux-sgx/enclave-sample/App/Enclave_u.c b/product-mini/platforms/linux-sgx/enclave-sample/App/Enclave_u.c
new file mode 100644
index 0000000..524fbe7
--- /dev/null
+++ b/product-mini/platforms/linux-sgx/enclave-sample/App/Enclave_u.c
@@ -0,0 +1,1021 @@
+#include "Enclave_u.h"
+#include <errno.h>
+
+typedef struct ms_ecall_handle_command_t {
+	unsigned int ms_cmd;
+	uint8_t* ms_cmd_buf;
+	unsigned int ms_cmd_buf_size;
+} ms_ecall_handle_command_t;
+
+typedef struct ms_ecall_iwasm_main_t {
+	uint8_t* ms_wasm_file_buf;
+	uint32_t ms_wasm_file_size;
+} ms_ecall_iwasm_main_t;
+
+typedef struct ms_ocall_print_t {
+	const char* ms_str;
+} ms_ocall_print_t;
+
+typedef struct ms_sgx_oc_cpuidex_t {
+	int* ms_cpuinfo;
+	int ms_leaf;
+	int ms_subleaf;
+} ms_sgx_oc_cpuidex_t;
+
+typedef struct ms_sgx_thread_wait_untrusted_event_ocall_t {
+	int ms_retval;
+	const void* ms_self;
+} ms_sgx_thread_wait_untrusted_event_ocall_t;
+
+typedef struct ms_sgx_thread_set_untrusted_event_ocall_t {
+	int ms_retval;
+	const void* ms_waiter;
+} ms_sgx_thread_set_untrusted_event_ocall_t;
+
+typedef struct ms_sgx_thread_setwait_untrusted_events_ocall_t {
+	int ms_retval;
+	const void* ms_waiter;
+	const void* ms_self;
+} ms_sgx_thread_setwait_untrusted_events_ocall_t;
+
+typedef struct ms_sgx_thread_set_multiple_untrusted_events_ocall_t {
+	int ms_retval;
+	const void** ms_waiters;
+	size_t ms_total;
+} ms_sgx_thread_set_multiple_untrusted_events_ocall_t;
+
+typedef struct ms_pthread_wait_timeout_ocall_t {
+	int ms_retval;
+	unsigned long long ms_waiter;
+	unsigned long long ms_timeout;
+} ms_pthread_wait_timeout_ocall_t;
+
+typedef struct ms_pthread_create_ocall_t {
+	int ms_retval;
+	unsigned long long ms_self;
+} ms_pthread_create_ocall_t;
+
+typedef struct ms_pthread_wakeup_ocall_t {
+	int ms_retval;
+	unsigned long long ms_waiter;
+} ms_pthread_wakeup_ocall_t;
+
+typedef struct ms_ocall_open_t {
+	int ms_retval;
+	const char* ms_pathname;
+	int ms_flags;
+	bool ms_has_mode;
+	unsigned int ms_mode;
+} ms_ocall_open_t;
+
+typedef struct ms_ocall_openat_t {
+	int ms_retval;
+	int ms_dirfd;
+	const char* ms_pathname;
+	int ms_flags;
+	bool ms_has_mode;
+	unsigned int ms_mode;
+} ms_ocall_openat_t;
+
+typedef struct ms_ocall_close_t {
+	int ms_retval;
+	int ms_fd;
+} ms_ocall_close_t;
+
+typedef struct ms_ocall_read_t {
+	ssize_t ms_retval;
+	int ms_fd;
+	void* ms_buf;
+	size_t ms_read_size;
+} ms_ocall_read_t;
+
+typedef struct ms_ocall_lseek_t {
+	off_t ms_retval;
+	int ms_fd;
+	off_t ms_offset;
+	int ms_whence;
+} ms_ocall_lseek_t;
+
+typedef struct ms_ocall_ftruncate_t {
+	int ms_retval;
+	int ms_fd;
+	off_t ms_length;
+} ms_ocall_ftruncate_t;
+
+typedef struct ms_ocall_fsync_t {
+	int ms_retval;
+	int ms_fd;
+} ms_ocall_fsync_t;
+
+typedef struct ms_ocall_fdatasync_t {
+	int ms_retval;
+	int ms_fd;
+} ms_ocall_fdatasync_t;
+
+typedef struct ms_ocall_isatty_t {
+	int ms_retval;
+	int ms_fd;
+} ms_ocall_isatty_t;
+
+typedef struct ms_ocall_fdopendir_t {
+	int ms_fd;
+	void** ms_p_dirp;
+} ms_ocall_fdopendir_t;
+
+typedef struct ms_ocall_readdir_t {
+	void* ms_retval;
+	void* ms_dirp;
+} ms_ocall_readdir_t;
+
+typedef struct ms_ocall_rewinddir_t {
+	void* ms_dirp;
+} ms_ocall_rewinddir_t;
+
+typedef struct ms_ocall_seekdir_t {
+	void* ms_dirp;
+	long int ms_loc;
+} ms_ocall_seekdir_t;
+
+typedef struct ms_ocall_telldir_t {
+	long int ms_retval;
+	void* ms_dirp;
+} ms_ocall_telldir_t;
+
+typedef struct ms_ocall_closedir_t {
+	int ms_retval;
+	void* ms_dirp;
+} ms_ocall_closedir_t;
+
+typedef struct ms_ocall_stat_t {
+	int ms_retval;
+	const char* ms_pathname;
+	void* ms_buf;
+	unsigned int ms_buf_len;
+} ms_ocall_stat_t;
+
+typedef struct ms_ocall_fstat_t {
+	int ms_retval;
+	int ms_fd;
+	void* ms_buf;
+	unsigned int ms_buf_len;
+} ms_ocall_fstat_t;
+
+typedef struct ms_ocall_fstatat_t {
+	int ms_retval;
+	int ms_dirfd;
+	const char* ms_pathname;
+	void* ms_buf;
+	unsigned int ms_buf_len;
+	int ms_flags;
+} ms_ocall_fstatat_t;
+
+typedef struct ms_ocall_mkdirat_t {
+	int ms_retval;
+	int ms_dirfd;
+	const char* ms_pathname;
+	unsigned int ms_mode;
+} ms_ocall_mkdirat_t;
+
+typedef struct ms_ocall_link_t {
+	int ms_retval;
+	const char* ms_oldpath;
+	const char* ms_newpath;
+} ms_ocall_link_t;
+
+typedef struct ms_ocall_linkat_t {
+	int ms_retval;
+	int ms_olddirfd;
+	const char* ms_oldpath;
+	int ms_newdirfd;
+	const char* ms_newpath;
+	int ms_flags;
+} ms_ocall_linkat_t;
+
+typedef struct ms_ocall_unlinkat_t {
+	int ms_retval;
+	int ms_dirfd;
+	const char* ms_pathname;
+	int ms_flags;
+} ms_ocall_unlinkat_t;
+
+typedef struct ms_ocall_readlinkat_t {
+	ssize_t ms_retval;
+	int ms_dirfd;
+	const char* ms_pathname;
+	char* ms_buf;
+	size_t ms_bufsiz;
+} ms_ocall_readlinkat_t;
+
+typedef struct ms_ocall_renameat_t {
+	int ms_retval;
+	int ms_olddirfd;
+	const char* ms_oldpath;
+	int ms_newdirfd;
+	const char* ms_newpath;
+} ms_ocall_renameat_t;
+
+typedef struct ms_ocall_symlinkat_t {
+	int ms_retval;
+	const char* ms_target;
+	int ms_newdirfd;
+	const char* ms_linkpath;
+} ms_ocall_symlinkat_t;
+
+typedef struct ms_ocall_ioctl_t {
+	int ms_retval;
+	int ms_fd;
+	unsigned long int ms_request;
+	void* ms_arg;
+	unsigned int ms_arg_len;
+} ms_ocall_ioctl_t;
+
+typedef struct ms_ocall_fcntl_t {
+	int ms_retval;
+	int ms_fd;
+	int ms_cmd;
+} ms_ocall_fcntl_t;
+
+typedef struct ms_ocall_fcntl_long_t {
+	int ms_retval;
+	int ms_fd;
+	int ms_cmd;
+	long int ms_arg;
+} ms_ocall_fcntl_long_t;
+
+typedef struct ms_ocall_realpath_t {
+	int ms_retval;
+	const char* ms_path;
+	char* ms_buf;
+	unsigned int ms_buf_len;
+} ms_ocall_realpath_t;
+
+typedef struct ms_ocall_posix_fallocate_t {
+	int ms_retval;
+	int ms_fd;
+	off_t ms_offset;
+	off_t ms_len;
+} ms_ocall_posix_fallocate_t;
+
+typedef struct ms_ocall_poll_t {
+	int ms_retval;
+	void* ms_fds;
+	unsigned int ms_nfds;
+	int ms_timeout;
+	unsigned int ms_fds_len;
+} ms_ocall_poll_t;
+
+typedef struct ms_ocall_getopt_t {
+	int ms_retval;
+	int ms_argc;
+	char* ms_argv_buf;
+	unsigned int ms_argv_buf_len;
+	const char* ms_optstring;
+} ms_ocall_getopt_t;
+
+typedef struct ms_ocall_getrandom_t {
+	ssize_t ms_retval;
+	void* ms_buf;
+	size_t ms_buflen;
+	unsigned int ms_flags;
+} ms_ocall_getrandom_t;
+
+typedef struct ms_ocall_getentropy_t {
+	int ms_retval;
+	void* ms_buffer;
+	size_t ms_length;
+} ms_ocall_getentropy_t;
+
+typedef struct ms_ocall_readv_t {
+	ssize_t ms_retval;
+	int ms_fd;
+	char* ms_iov_buf;
+	unsigned int ms_buf_size;
+	int ms_iovcnt;
+	bool ms_has_offset;
+	off_t ms_offset;
+} ms_ocall_readv_t;
+
+typedef struct ms_ocall_writev_t {
+	ssize_t ms_retval;
+	int ms_fd;
+	char* ms_iov_buf;
+	unsigned int ms_buf_size;
+	int ms_iovcnt;
+	bool ms_has_offset;
+	off_t ms_offset;
+} ms_ocall_writev_t;
+
+typedef struct ms_ocall_clock_gettime_t {
+	int ms_retval;
+	unsigned int ms_clock_id;
+	void* ms_tp_buf;
+	unsigned int ms_tp_buf_size;
+} ms_ocall_clock_gettime_t;
+
+typedef struct ms_ocall_clock_getres_t {
+	int ms_retval;
+	int ms_clock_id;
+	void* ms_res_buf;
+	unsigned int ms_res_buf_size;
+} ms_ocall_clock_getres_t;
+
+typedef struct ms_ocall_utimensat_t {
+	int ms_retval;
+	int ms_dirfd;
+	const char* ms_pathname;
+	const void* ms_times_buf;
+	unsigned int ms_times_buf_size;
+	int ms_flags;
+} ms_ocall_utimensat_t;
+
+typedef struct ms_ocall_futimens_t {
+	int ms_retval;
+	int ms_fd;
+	const void* ms_times_buf;
+	unsigned int ms_times_buf_size;
+} ms_ocall_futimens_t;
+
+typedef struct ms_ocall_clock_nanosleep_t {
+	int ms_retval;
+	unsigned int ms_clock_id;
+	int ms_flags;
+	const void* ms_req_buf;
+	unsigned int ms_req_buf_size;
+	void* ms_rem_buf;
+	unsigned int ms_rem_buf_size;
+} ms_ocall_clock_nanosleep_t;
+
+typedef struct ms_ocall_raise_t {
+	int ms_retval;
+	int ms_sig;
+} ms_ocall_raise_t;
+
+typedef struct ms_ocall_sched_yield_t {
+	int ms_retval;
+} ms_ocall_sched_yield_t;
+
+typedef struct ms_ocall_pthread_rwlock_init_t {
+	int ms_retval;
+	void** ms_rwlock;
+	void* ms_attr;
+} ms_ocall_pthread_rwlock_init_t;
+
+typedef struct ms_ocall_pthread_rwlock_destroy_t {
+	int ms_retval;
+	void* ms_rwlock;
+} ms_ocall_pthread_rwlock_destroy_t;
+
+typedef struct ms_ocall_pthread_rwlock_rdlock_t {
+	int ms_retval;
+	void* ms_rwlock;
+} ms_ocall_pthread_rwlock_rdlock_t;
+
+typedef struct ms_ocall_pthread_rwlock_wrlock_t {
+	int ms_retval;
+	void* ms_rwlock;
+} ms_ocall_pthread_rwlock_wrlock_t;
+
+typedef struct ms_ocall_pthread_rwlock_unlock_t {
+	int ms_retval;
+	void* ms_rwlock;
+} ms_ocall_pthread_rwlock_unlock_t;
+
+typedef struct ms_ocall_get_errno_t {
+	int ms_retval;
+} ms_ocall_get_errno_t;
+
+typedef struct ms_ocall_socket_t {
+	int ms_retval;
+	int ms_domain;
+	int ms_type;
+	int ms_protocol;
+} ms_ocall_socket_t;
+
+typedef struct ms_ocall_getsockopt_t {
+	int ms_retval;
+	int ms_sockfd;
+	int ms_level;
+	int ms_optname;
+	void* ms_val_buf;
+	unsigned int ms_val_buf_size;
+	void* ms_len_buf;
+} ms_ocall_getsockopt_t;
+
+typedef struct ms_ocall_sendmsg_t {
+	ssize_t ms_retval;
+	int ms_sockfd;
+	void* ms_msg_buf;
+	unsigned int ms_msg_buf_size;
+	int ms_flags;
+} ms_ocall_sendmsg_t;
+
+typedef struct ms_ocall_recvmsg_t {
+	ssize_t ms_retval;
+	int ms_sockfd;
+	void* ms_msg_buf;
+	unsigned int ms_msg_buf_size;
+	int ms_flags;
+} ms_ocall_recvmsg_t;
+
+typedef struct ms_ocall_shutdown_t {
+	int ms_retval;
+	int ms_sockfd;
+	int ms_how;
+} ms_ocall_shutdown_t;
+
+static sgx_status_t SGX_CDECL Enclave_ocall_print(void* pms)
+{
+	ms_ocall_print_t* ms = SGX_CAST(ms_ocall_print_t*, pms);
+	ocall_print(ms->ms_str);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_sgx_oc_cpuidex(void* pms)
+{
+	ms_sgx_oc_cpuidex_t* ms = SGX_CAST(ms_sgx_oc_cpuidex_t*, pms);
+	sgx_oc_cpuidex(ms->ms_cpuinfo, ms->ms_leaf, ms->ms_subleaf);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_sgx_thread_wait_untrusted_event_ocall(void* pms)
+{
+	ms_sgx_thread_wait_untrusted_event_ocall_t* ms = SGX_CAST(ms_sgx_thread_wait_untrusted_event_ocall_t*, pms);
+	ms->ms_retval = sgx_thread_wait_untrusted_event_ocall(ms->ms_self);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_sgx_thread_set_untrusted_event_ocall(void* pms)
+{
+	ms_sgx_thread_set_untrusted_event_ocall_t* ms = SGX_CAST(ms_sgx_thread_set_untrusted_event_ocall_t*, pms);
+	ms->ms_retval = sgx_thread_set_untrusted_event_ocall(ms->ms_waiter);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_sgx_thread_setwait_untrusted_events_ocall(void* pms)
+{
+	ms_sgx_thread_setwait_untrusted_events_ocall_t* ms = SGX_CAST(ms_sgx_thread_setwait_untrusted_events_ocall_t*, pms);
+	ms->ms_retval = sgx_thread_setwait_untrusted_events_ocall(ms->ms_waiter, ms->ms_self);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_sgx_thread_set_multiple_untrusted_events_ocall(void* pms)
+{
+	ms_sgx_thread_set_multiple_untrusted_events_ocall_t* ms = SGX_CAST(ms_sgx_thread_set_multiple_untrusted_events_ocall_t*, pms);
+	ms->ms_retval = sgx_thread_set_multiple_untrusted_events_ocall(ms->ms_waiters, ms->ms_total);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_pthread_wait_timeout_ocall(void* pms)
+{
+	ms_pthread_wait_timeout_ocall_t* ms = SGX_CAST(ms_pthread_wait_timeout_ocall_t*, pms);
+	ms->ms_retval = pthread_wait_timeout_ocall(ms->ms_waiter, ms->ms_timeout);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_pthread_create_ocall(void* pms)
+{
+	ms_pthread_create_ocall_t* ms = SGX_CAST(ms_pthread_create_ocall_t*, pms);
+	ms->ms_retval = pthread_create_ocall(ms->ms_self);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_pthread_wakeup_ocall(void* pms)
+{
+	ms_pthread_wakeup_ocall_t* ms = SGX_CAST(ms_pthread_wakeup_ocall_t*, pms);
+	ms->ms_retval = pthread_wakeup_ocall(ms->ms_waiter);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_open(void* pms)
+{
+	ms_ocall_open_t* ms = SGX_CAST(ms_ocall_open_t*, pms);
+	ms->ms_retval = ocall_open(ms->ms_pathname, ms->ms_flags, ms->ms_has_mode, ms->ms_mode);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_openat(void* pms)
+{
+	ms_ocall_openat_t* ms = SGX_CAST(ms_ocall_openat_t*, pms);
+	ms->ms_retval = ocall_openat(ms->ms_dirfd, ms->ms_pathname, ms->ms_flags, ms->ms_has_mode, ms->ms_mode);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_close(void* pms)
+{
+	ms_ocall_close_t* ms = SGX_CAST(ms_ocall_close_t*, pms);
+	ms->ms_retval = ocall_close(ms->ms_fd);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_read(void* pms)
+{
+	ms_ocall_read_t* ms = SGX_CAST(ms_ocall_read_t*, pms);
+	ms->ms_retval = ocall_read(ms->ms_fd, ms->ms_buf, ms->ms_read_size);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_lseek(void* pms)
+{
+	ms_ocall_lseek_t* ms = SGX_CAST(ms_ocall_lseek_t*, pms);
+	ms->ms_retval = ocall_lseek(ms->ms_fd, ms->ms_offset, ms->ms_whence);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_ftruncate(void* pms)
+{
+	ms_ocall_ftruncate_t* ms = SGX_CAST(ms_ocall_ftruncate_t*, pms);
+	ms->ms_retval = ocall_ftruncate(ms->ms_fd, ms->ms_length);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_fsync(void* pms)
+{
+	ms_ocall_fsync_t* ms = SGX_CAST(ms_ocall_fsync_t*, pms);
+	ms->ms_retval = ocall_fsync(ms->ms_fd);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_fdatasync(void* pms)
+{
+	ms_ocall_fdatasync_t* ms = SGX_CAST(ms_ocall_fdatasync_t*, pms);
+	ms->ms_retval = ocall_fdatasync(ms->ms_fd);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_isatty(void* pms)
+{
+	ms_ocall_isatty_t* ms = SGX_CAST(ms_ocall_isatty_t*, pms);
+	ms->ms_retval = ocall_isatty(ms->ms_fd);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_fdopendir(void* pms)
+{
+	ms_ocall_fdopendir_t* ms = SGX_CAST(ms_ocall_fdopendir_t*, pms);
+	ocall_fdopendir(ms->ms_fd, ms->ms_p_dirp);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_readdir(void* pms)
+{
+	ms_ocall_readdir_t* ms = SGX_CAST(ms_ocall_readdir_t*, pms);
+	ms->ms_retval = ocall_readdir(ms->ms_dirp);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_rewinddir(void* pms)
+{
+	ms_ocall_rewinddir_t* ms = SGX_CAST(ms_ocall_rewinddir_t*, pms);
+	ocall_rewinddir(ms->ms_dirp);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_seekdir(void* pms)
+{
+	ms_ocall_seekdir_t* ms = SGX_CAST(ms_ocall_seekdir_t*, pms);
+	ocall_seekdir(ms->ms_dirp, ms->ms_loc);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_telldir(void* pms)
+{
+	ms_ocall_telldir_t* ms = SGX_CAST(ms_ocall_telldir_t*, pms);
+	ms->ms_retval = ocall_telldir(ms->ms_dirp);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_closedir(void* pms)
+{
+	ms_ocall_closedir_t* ms = SGX_CAST(ms_ocall_closedir_t*, pms);
+	ms->ms_retval = ocall_closedir(ms->ms_dirp);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_stat(void* pms)
+{
+	ms_ocall_stat_t* ms = SGX_CAST(ms_ocall_stat_t*, pms);
+	ms->ms_retval = ocall_stat(ms->ms_pathname, ms->ms_buf, ms->ms_buf_len);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_fstat(void* pms)
+{
+	ms_ocall_fstat_t* ms = SGX_CAST(ms_ocall_fstat_t*, pms);
+	ms->ms_retval = ocall_fstat(ms->ms_fd, ms->ms_buf, ms->ms_buf_len);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_fstatat(void* pms)
+{
+	ms_ocall_fstatat_t* ms = SGX_CAST(ms_ocall_fstatat_t*, pms);
+	ms->ms_retval = ocall_fstatat(ms->ms_dirfd, ms->ms_pathname, ms->ms_buf, ms->ms_buf_len, ms->ms_flags);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_mkdirat(void* pms)
+{
+	ms_ocall_mkdirat_t* ms = SGX_CAST(ms_ocall_mkdirat_t*, pms);
+	ms->ms_retval = ocall_mkdirat(ms->ms_dirfd, ms->ms_pathname, ms->ms_mode);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_link(void* pms)
+{
+	ms_ocall_link_t* ms = SGX_CAST(ms_ocall_link_t*, pms);
+	ms->ms_retval = ocall_link(ms->ms_oldpath, ms->ms_newpath);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_linkat(void* pms)
+{
+	ms_ocall_linkat_t* ms = SGX_CAST(ms_ocall_linkat_t*, pms);
+	ms->ms_retval = ocall_linkat(ms->ms_olddirfd, ms->ms_oldpath, ms->ms_newdirfd, ms->ms_newpath, ms->ms_flags);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_unlinkat(void* pms)
+{
+	ms_ocall_unlinkat_t* ms = SGX_CAST(ms_ocall_unlinkat_t*, pms);
+	ms->ms_retval = ocall_unlinkat(ms->ms_dirfd, ms->ms_pathname, ms->ms_flags);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_readlinkat(void* pms)
+{
+	ms_ocall_readlinkat_t* ms = SGX_CAST(ms_ocall_readlinkat_t*, pms);
+	ms->ms_retval = ocall_readlinkat(ms->ms_dirfd, ms->ms_pathname, ms->ms_buf, ms->ms_bufsiz);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_renameat(void* pms)
+{
+	ms_ocall_renameat_t* ms = SGX_CAST(ms_ocall_renameat_t*, pms);
+	ms->ms_retval = ocall_renameat(ms->ms_olddirfd, ms->ms_oldpath, ms->ms_newdirfd, ms->ms_newpath);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_symlinkat(void* pms)
+{
+	ms_ocall_symlinkat_t* ms = SGX_CAST(ms_ocall_symlinkat_t*, pms);
+	ms->ms_retval = ocall_symlinkat(ms->ms_target, ms->ms_newdirfd, ms->ms_linkpath);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_ioctl(void* pms)
+{
+	ms_ocall_ioctl_t* ms = SGX_CAST(ms_ocall_ioctl_t*, pms);
+	ms->ms_retval = ocall_ioctl(ms->ms_fd, ms->ms_request, ms->ms_arg, ms->ms_arg_len);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_fcntl(void* pms)
+{
+	ms_ocall_fcntl_t* ms = SGX_CAST(ms_ocall_fcntl_t*, pms);
+	ms->ms_retval = ocall_fcntl(ms->ms_fd, ms->ms_cmd);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_fcntl_long(void* pms)
+{
+	ms_ocall_fcntl_long_t* ms = SGX_CAST(ms_ocall_fcntl_long_t*, pms);
+	ms->ms_retval = ocall_fcntl_long(ms->ms_fd, ms->ms_cmd, ms->ms_arg);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_realpath(void* pms)
+{
+	ms_ocall_realpath_t* ms = SGX_CAST(ms_ocall_realpath_t*, pms);
+	ms->ms_retval = ocall_realpath(ms->ms_path, ms->ms_buf, ms->ms_buf_len);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_posix_fallocate(void* pms)
+{
+	ms_ocall_posix_fallocate_t* ms = SGX_CAST(ms_ocall_posix_fallocate_t*, pms);
+	ms->ms_retval = ocall_posix_fallocate(ms->ms_fd, ms->ms_offset, ms->ms_len);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_poll(void* pms)
+{
+	ms_ocall_poll_t* ms = SGX_CAST(ms_ocall_poll_t*, pms);
+	ms->ms_retval = ocall_poll(ms->ms_fds, ms->ms_nfds, ms->ms_timeout, ms->ms_fds_len);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_getopt(void* pms)
+{
+	ms_ocall_getopt_t* ms = SGX_CAST(ms_ocall_getopt_t*, pms);
+	ms->ms_retval = ocall_getopt(ms->ms_argc, ms->ms_argv_buf, ms->ms_argv_buf_len, ms->ms_optstring);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_getrandom(void* pms)
+{
+	ms_ocall_getrandom_t* ms = SGX_CAST(ms_ocall_getrandom_t*, pms);
+	ms->ms_retval = ocall_getrandom(ms->ms_buf, ms->ms_buflen, ms->ms_flags);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_getentropy(void* pms)
+{
+	ms_ocall_getentropy_t* ms = SGX_CAST(ms_ocall_getentropy_t*, pms);
+	ms->ms_retval = ocall_getentropy(ms->ms_buffer, ms->ms_length);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_readv(void* pms)
+{
+	ms_ocall_readv_t* ms = SGX_CAST(ms_ocall_readv_t*, pms);
+	ms->ms_retval = ocall_readv(ms->ms_fd, ms->ms_iov_buf, ms->ms_buf_size, ms->ms_iovcnt, ms->ms_has_offset, ms->ms_offset);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_writev(void* pms)
+{
+	ms_ocall_writev_t* ms = SGX_CAST(ms_ocall_writev_t*, pms);
+	ms->ms_retval = ocall_writev(ms->ms_fd, ms->ms_iov_buf, ms->ms_buf_size, ms->ms_iovcnt, ms->ms_has_offset, ms->ms_offset);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_clock_gettime(void* pms)
+{
+	ms_ocall_clock_gettime_t* ms = SGX_CAST(ms_ocall_clock_gettime_t*, pms);
+	ms->ms_retval = ocall_clock_gettime(ms->ms_clock_id, ms->ms_tp_buf, ms->ms_tp_buf_size);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_clock_getres(void* pms)
+{
+	ms_ocall_clock_getres_t* ms = SGX_CAST(ms_ocall_clock_getres_t*, pms);
+	ms->ms_retval = ocall_clock_getres(ms->ms_clock_id, ms->ms_res_buf, ms->ms_res_buf_size);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_utimensat(void* pms)
+{
+	ms_ocall_utimensat_t* ms = SGX_CAST(ms_ocall_utimensat_t*, pms);
+	ms->ms_retval = ocall_utimensat(ms->ms_dirfd, ms->ms_pathname, ms->ms_times_buf, ms->ms_times_buf_size, ms->ms_flags);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_futimens(void* pms)
+{
+	ms_ocall_futimens_t* ms = SGX_CAST(ms_ocall_futimens_t*, pms);
+	ms->ms_retval = ocall_futimens(ms->ms_fd, ms->ms_times_buf, ms->ms_times_buf_size);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_clock_nanosleep(void* pms)
+{
+	ms_ocall_clock_nanosleep_t* ms = SGX_CAST(ms_ocall_clock_nanosleep_t*, pms);
+	ms->ms_retval = ocall_clock_nanosleep(ms->ms_clock_id, ms->ms_flags, ms->ms_req_buf, ms->ms_req_buf_size, ms->ms_rem_buf, ms->ms_rem_buf_size);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_raise(void* pms)
+{
+	ms_ocall_raise_t* ms = SGX_CAST(ms_ocall_raise_t*, pms);
+	ms->ms_retval = ocall_raise(ms->ms_sig);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_sched_yield(void* pms)
+{
+	ms_ocall_sched_yield_t* ms = SGX_CAST(ms_ocall_sched_yield_t*, pms);
+	ms->ms_retval = ocall_sched_yield();
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_pthread_rwlock_init(void* pms)
+{
+	ms_ocall_pthread_rwlock_init_t* ms = SGX_CAST(ms_ocall_pthread_rwlock_init_t*, pms);
+	ms->ms_retval = ocall_pthread_rwlock_init(ms->ms_rwlock, ms->ms_attr);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_pthread_rwlock_destroy(void* pms)
+{
+	ms_ocall_pthread_rwlock_destroy_t* ms = SGX_CAST(ms_ocall_pthread_rwlock_destroy_t*, pms);
+	ms->ms_retval = ocall_pthread_rwlock_destroy(ms->ms_rwlock);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_pthread_rwlock_rdlock(void* pms)
+{
+	ms_ocall_pthread_rwlock_rdlock_t* ms = SGX_CAST(ms_ocall_pthread_rwlock_rdlock_t*, pms);
+	ms->ms_retval = ocall_pthread_rwlock_rdlock(ms->ms_rwlock);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_pthread_rwlock_wrlock(void* pms)
+{
+	ms_ocall_pthread_rwlock_wrlock_t* ms = SGX_CAST(ms_ocall_pthread_rwlock_wrlock_t*, pms);
+	ms->ms_retval = ocall_pthread_rwlock_wrlock(ms->ms_rwlock);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_pthread_rwlock_unlock(void* pms)
+{
+	ms_ocall_pthread_rwlock_unlock_t* ms = SGX_CAST(ms_ocall_pthread_rwlock_unlock_t*, pms);
+	ms->ms_retval = ocall_pthread_rwlock_unlock(ms->ms_rwlock);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_get_errno(void* pms)
+{
+	ms_ocall_get_errno_t* ms = SGX_CAST(ms_ocall_get_errno_t*, pms);
+	ms->ms_retval = ocall_get_errno();
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_socket(void* pms)
+{
+	ms_ocall_socket_t* ms = SGX_CAST(ms_ocall_socket_t*, pms);
+	ms->ms_retval = ocall_socket(ms->ms_domain, ms->ms_type, ms->ms_protocol);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_getsockopt(void* pms)
+{
+	ms_ocall_getsockopt_t* ms = SGX_CAST(ms_ocall_getsockopt_t*, pms);
+	ms->ms_retval = ocall_getsockopt(ms->ms_sockfd, ms->ms_level, ms->ms_optname, ms->ms_val_buf, ms->ms_val_buf_size, ms->ms_len_buf);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_sendmsg(void* pms)
+{
+	ms_ocall_sendmsg_t* ms = SGX_CAST(ms_ocall_sendmsg_t*, pms);
+	ms->ms_retval = ocall_sendmsg(ms->ms_sockfd, ms->ms_msg_buf, ms->ms_msg_buf_size, ms->ms_flags);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_recvmsg(void* pms)
+{
+	ms_ocall_recvmsg_t* ms = SGX_CAST(ms_ocall_recvmsg_t*, pms);
+	ms->ms_retval = ocall_recvmsg(ms->ms_sockfd, ms->ms_msg_buf, ms->ms_msg_buf_size, ms->ms_flags);
+
+	return SGX_SUCCESS;
+}
+
+static sgx_status_t SGX_CDECL Enclave_ocall_shutdown(void* pms)
+{
+	ms_ocall_shutdown_t* ms = SGX_CAST(ms_ocall_shutdown_t*, pms);
+	ms->ms_retval = ocall_shutdown(ms->ms_sockfd, ms->ms_how);
+
+	return SGX_SUCCESS;
+}
+
+static const struct {
+	size_t nr_ocall;
+	void * table[63];
+} ocall_table_Enclave = {
+	63,
+	{
+		(void*)Enclave_ocall_print,
+		(void*)Enclave_sgx_oc_cpuidex,
+		(void*)Enclave_sgx_thread_wait_untrusted_event_ocall,
+		(void*)Enclave_sgx_thread_set_untrusted_event_ocall,
+		(void*)Enclave_sgx_thread_setwait_untrusted_events_ocall,
+		(void*)Enclave_sgx_thread_set_multiple_untrusted_events_ocall,
+		(void*)Enclave_pthread_wait_timeout_ocall,
+		(void*)Enclave_pthread_create_ocall,
+		(void*)Enclave_pthread_wakeup_ocall,
+		(void*)Enclave_ocall_open,
+		(void*)Enclave_ocall_openat,
+		(void*)Enclave_ocall_close,
+		(void*)Enclave_ocall_read,
+		(void*)Enclave_ocall_lseek,
+		(void*)Enclave_ocall_ftruncate,
+		(void*)Enclave_ocall_fsync,
+		(void*)Enclave_ocall_fdatasync,
+		(void*)Enclave_ocall_isatty,
+		(void*)Enclave_ocall_fdopendir,
+		(void*)Enclave_ocall_readdir,
+		(void*)Enclave_ocall_rewinddir,
+		(void*)Enclave_ocall_seekdir,
+		(void*)Enclave_ocall_telldir,
+		(void*)Enclave_ocall_closedir,
+		(void*)Enclave_ocall_stat,
+		(void*)Enclave_ocall_fstat,
+		(void*)Enclave_ocall_fstatat,
+		(void*)Enclave_ocall_mkdirat,
+		(void*)Enclave_ocall_link,
+		(void*)Enclave_ocall_linkat,
+		(void*)Enclave_ocall_unlinkat,
+		(void*)Enclave_ocall_readlinkat,
+		(void*)Enclave_ocall_renameat,
+		(void*)Enclave_ocall_symlinkat,
+		(void*)Enclave_ocall_ioctl,
+		(void*)Enclave_ocall_fcntl,
+		(void*)Enclave_ocall_fcntl_long,
+		(void*)Enclave_ocall_realpath,
+		(void*)Enclave_ocall_posix_fallocate,
+		(void*)Enclave_ocall_poll,
+		(void*)Enclave_ocall_getopt,
+		(void*)Enclave_ocall_getrandom,
+		(void*)Enclave_ocall_getentropy,
+		(void*)Enclave_ocall_readv,
+		(void*)Enclave_ocall_writev,
+		(void*)Enclave_ocall_clock_gettime,
+		(void*)Enclave_ocall_clock_getres,
+		(void*)Enclave_ocall_utimensat,
+		(void*)Enclave_ocall_futimens,
+		(void*)Enclave_ocall_clock_nanosleep,
+		(void*)Enclave_ocall_raise,
+		(void*)Enclave_ocall_sched_yield,
+		(void*)Enclave_ocall_pthread_rwlock_init,
+		(void*)Enclave_ocall_pthread_rwlock_destroy,
+		(void*)Enclave_ocall_pthread_rwlock_rdlock,
+		(void*)Enclave_ocall_pthread_rwlock_wrlock,
+		(void*)Enclave_ocall_pthread_rwlock_unlock,
+		(void*)Enclave_ocall_get_errno,
+		(void*)Enclave_ocall_socket,
+		(void*)Enclave_ocall_getsockopt,
+		(void*)Enclave_ocall_sendmsg,
+		(void*)Enclave_ocall_recvmsg,
+		(void*)Enclave_ocall_shutdown,
+	}
+};
+sgx_status_t ecall_handle_command(sgx_enclave_id_t eid, unsigned int cmd, uint8_t* cmd_buf, unsigned int cmd_buf_size)
+{
+	sgx_status_t status;
+	ms_ecall_handle_command_t ms;
+	ms.ms_cmd = cmd;
+	ms.ms_cmd_buf = cmd_buf;
+	ms.ms_cmd_buf_size = cmd_buf_size;
+	status = sgx_ecall(eid, 0, &ocall_table_Enclave, &ms);
+	return status;
+}
+
+sgx_status_t ecall_iwasm_main(sgx_enclave_id_t eid, uint8_t* wasm_file_buf, uint32_t wasm_file_size)
+{
+	sgx_status_t status;
+	ms_ecall_iwasm_main_t ms;
+	ms.ms_wasm_file_buf = wasm_file_buf;
+	ms.ms_wasm_file_size = wasm_file_size;
+	status = sgx_ecall(eid, 1, &ocall_table_Enclave, &ms);
+	return status;
+}
+
diff --git a/product-mini/platforms/linux-sgx/enclave-sample/App/Enclave_u.h b/product-mini/platforms/linux-sgx/enclave-sample/App/Enclave_u.h
new file mode 100644
index 0000000..f35fc3d
--- /dev/null
+++ b/product-mini/platforms/linux-sgx/enclave-sample/App/Enclave_u.h
@@ -0,0 +1,282 @@
+#ifndef ENCLAVE_U_H__
+#define ENCLAVE_U_H__
+
+#include <stdint.h>
+#include <wchar.h>
+#include <stddef.h>
+#include <string.h>
+#include "sgx_edger8r.h" /* for sgx_status_t etc. */
+
+#include "stdint.h"
+#include "stdbool.h"
+#include "unistd.h"
+
+#include <stdlib.h> /* for size_t */
+
+#define SGX_CAST(type, item) ((type)(item))
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef OCALL_PRINT_DEFINED__
+#define OCALL_PRINT_DEFINED__
+void SGX_UBRIDGE(SGX_NOCONVENTION, ocall_print, (const char* str));
+#endif
+#ifndef SGX_OC_CPUIDEX_DEFINED__
+#define SGX_OC_CPUIDEX_DEFINED__
+void SGX_UBRIDGE(SGX_CDECL, sgx_oc_cpuidex, (int cpuinfo[4], int leaf, int subleaf));
+#endif
+#ifndef SGX_THREAD_WAIT_UNTRUSTED_EVENT_OCALL_DEFINED__
+#define SGX_THREAD_WAIT_UNTRUSTED_EVENT_OCALL_DEFINED__
+int SGX_UBRIDGE(SGX_CDECL, sgx_thread_wait_untrusted_event_ocall, (const void* self));
+#endif
+#ifndef SGX_THREAD_SET_UNTRUSTED_EVENT_OCALL_DEFINED__
+#define SGX_THREAD_SET_UNTRUSTED_EVENT_OCALL_DEFINED__
+int SGX_UBRIDGE(SGX_CDECL, sgx_thread_set_untrusted_event_ocall, (const void* waiter));
+#endif
+#ifndef SGX_THREAD_SETWAIT_UNTRUSTED_EVENTS_OCALL_DEFINED__
+#define SGX_THREAD_SETWAIT_UNTRUSTED_EVENTS_OCALL_DEFINED__
+int SGX_UBRIDGE(SGX_CDECL, sgx_thread_setwait_untrusted_events_ocall, (const void* waiter, const void* self));
+#endif
+#ifndef SGX_THREAD_SET_MULTIPLE_UNTRUSTED_EVENTS_OCALL_DEFINED__
+#define SGX_THREAD_SET_MULTIPLE_UNTRUSTED_EVENTS_OCALL_DEFINED__
+int SGX_UBRIDGE(SGX_CDECL, sgx_thread_set_multiple_untrusted_events_ocall, (const void** waiters, size_t total));
+#endif
+#ifndef PTHREAD_WAIT_TIMEOUT_OCALL_DEFINED__
+#define PTHREAD_WAIT_TIMEOUT_OCALL_DEFINED__
+int SGX_UBRIDGE(SGX_CDECL, pthread_wait_timeout_ocall, (unsigned long long waiter, unsigned long long timeout));
+#endif
+#ifndef PTHREAD_CREATE_OCALL_DEFINED__
+#define PTHREAD_CREATE_OCALL_DEFINED__
+int SGX_UBRIDGE(SGX_CDECL, pthread_create_ocall, (unsigned long long self));
+#endif
+#ifndef PTHREAD_WAKEUP_OCALL_DEFINED__
+#define PTHREAD_WAKEUP_OCALL_DEFINED__
+int SGX_UBRIDGE(SGX_CDECL, pthread_wakeup_ocall, (unsigned long long waiter));
+#endif
+#ifndef OCALL_OPEN_DEFINED__
+#define OCALL_OPEN_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_open, (const char* pathname, int flags, bool has_mode, unsigned int mode));
+#endif
+#ifndef OCALL_OPENAT_DEFINED__
+#define OCALL_OPENAT_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_openat, (int dirfd, const char* pathname, int flags, bool has_mode, unsigned int mode));
+#endif
+#ifndef OCALL_CLOSE_DEFINED__
+#define OCALL_CLOSE_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_close, (int fd));
+#endif
+#ifndef OCALL_READ_DEFINED__
+#define OCALL_READ_DEFINED__
+ssize_t SGX_UBRIDGE(SGX_NOCONVENTION, ocall_read, (int fd, void* buf, size_t read_size));
+#endif
+#ifndef OCALL_LSEEK_DEFINED__
+#define OCALL_LSEEK_DEFINED__
+off_t SGX_UBRIDGE(SGX_NOCONVENTION, ocall_lseek, (int fd, off_t offset, int whence));
+#endif
+#ifndef OCALL_FTRUNCATE_DEFINED__
+#define OCALL_FTRUNCATE_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_ftruncate, (int fd, off_t length));
+#endif
+#ifndef OCALL_FSYNC_DEFINED__
+#define OCALL_FSYNC_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_fsync, (int fd));
+#endif
+#ifndef OCALL_FDATASYNC_DEFINED__
+#define OCALL_FDATASYNC_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_fdatasync, (int fd));
+#endif
+#ifndef OCALL_ISATTY_DEFINED__
+#define OCALL_ISATTY_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_isatty, (int fd));
+#endif
+#ifndef OCALL_FDOPENDIR_DEFINED__
+#define OCALL_FDOPENDIR_DEFINED__
+void SGX_UBRIDGE(SGX_NOCONVENTION, ocall_fdopendir, (int fd, void** p_dirp));
+#endif
+#ifndef OCALL_READDIR_DEFINED__
+#define OCALL_READDIR_DEFINED__
+void* SGX_UBRIDGE(SGX_NOCONVENTION, ocall_readdir, (void* dirp));
+#endif
+#ifndef OCALL_REWINDDIR_DEFINED__
+#define OCALL_REWINDDIR_DEFINED__
+void SGX_UBRIDGE(SGX_NOCONVENTION, ocall_rewinddir, (void* dirp));
+#endif
+#ifndef OCALL_SEEKDIR_DEFINED__
+#define OCALL_SEEKDIR_DEFINED__
+void SGX_UBRIDGE(SGX_NOCONVENTION, ocall_seekdir, (void* dirp, long int loc));
+#endif
+#ifndef OCALL_TELLDIR_DEFINED__
+#define OCALL_TELLDIR_DEFINED__
+long int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_telldir, (void* dirp));
+#endif
+#ifndef OCALL_CLOSEDIR_DEFINED__
+#define OCALL_CLOSEDIR_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_closedir, (void* dirp));
+#endif
+#ifndef OCALL_STAT_DEFINED__
+#define OCALL_STAT_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_stat, (const char* pathname, void* buf, unsigned int buf_len));
+#endif
+#ifndef OCALL_FSTAT_DEFINED__
+#define OCALL_FSTAT_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_fstat, (int fd, void* buf, unsigned int buf_len));
+#endif
+#ifndef OCALL_FSTATAT_DEFINED__
+#define OCALL_FSTATAT_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_fstatat, (int dirfd, const char* pathname, void* buf, unsigned int buf_len, int flags));
+#endif
+#ifndef OCALL_MKDIRAT_DEFINED__
+#define OCALL_MKDIRAT_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_mkdirat, (int dirfd, const char* pathname, unsigned int mode));
+#endif
+#ifndef OCALL_LINK_DEFINED__
+#define OCALL_LINK_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_link, (const char* oldpath, const char* newpath));
+#endif
+#ifndef OCALL_LINKAT_DEFINED__
+#define OCALL_LINKAT_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_linkat, (int olddirfd, const char* oldpath, int newdirfd, const char* newpath, int flags));
+#endif
+#ifndef OCALL_UNLINKAT_DEFINED__
+#define OCALL_UNLINKAT_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_unlinkat, (int dirfd, const char* pathname, int flags));
+#endif
+#ifndef OCALL_READLINKAT_DEFINED__
+#define OCALL_READLINKAT_DEFINED__
+ssize_t SGX_UBRIDGE(SGX_NOCONVENTION, ocall_readlinkat, (int dirfd, const char* pathname, char* buf, size_t bufsiz));
+#endif
+#ifndef OCALL_RENAMEAT_DEFINED__
+#define OCALL_RENAMEAT_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_renameat, (int olddirfd, const char* oldpath, int newdirfd, const char* newpath));
+#endif
+#ifndef OCALL_SYMLINKAT_DEFINED__
+#define OCALL_SYMLINKAT_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_symlinkat, (const char* target, int newdirfd, const char* linkpath));
+#endif
+#ifndef OCALL_IOCTL_DEFINED__
+#define OCALL_IOCTL_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_ioctl, (int fd, unsigned long int request, void* arg, unsigned int arg_len));
+#endif
+#ifndef OCALL_FCNTL_DEFINED__
+#define OCALL_FCNTL_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_fcntl, (int fd, int cmd));
+#endif
+#ifndef OCALL_FCNTL_LONG_DEFINED__
+#define OCALL_FCNTL_LONG_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_fcntl_long, (int fd, int cmd, long int arg));
+#endif
+#ifndef OCALL_REALPATH_DEFINED__
+#define OCALL_REALPATH_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_realpath, (const char* path, char* buf, unsigned int buf_len));
+#endif
+#ifndef OCALL_POSIX_FALLOCATE_DEFINED__
+#define OCALL_POSIX_FALLOCATE_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_posix_fallocate, (int fd, off_t offset, off_t len));
+#endif
+#ifndef OCALL_POLL_DEFINED__
+#define OCALL_POLL_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_poll, (void* fds, unsigned int nfds, int timeout, unsigned int fds_len));
+#endif
+#ifndef OCALL_GETOPT_DEFINED__
+#define OCALL_GETOPT_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_getopt, (int argc, char* argv_buf, unsigned int argv_buf_len, const char* optstring));
+#endif
+#ifndef OCALL_GETRANDOM_DEFINED__
+#define OCALL_GETRANDOM_DEFINED__
+ssize_t SGX_UBRIDGE(SGX_NOCONVENTION, ocall_getrandom, (void* buf, size_t buflen, unsigned int flags));
+#endif
+#ifndef OCALL_GETENTROPY_DEFINED__
+#define OCALL_GETENTROPY_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_getentropy, (void* buffer, size_t length));
+#endif
+#ifndef OCALL_READV_DEFINED__
+#define OCALL_READV_DEFINED__
+ssize_t SGX_UBRIDGE(SGX_NOCONVENTION, ocall_readv, (int fd, char* iov_buf, unsigned int buf_size, int iovcnt, bool has_offset, off_t offset));
+#endif
+#ifndef OCALL_WRITEV_DEFINED__
+#define OCALL_WRITEV_DEFINED__
+ssize_t SGX_UBRIDGE(SGX_NOCONVENTION, ocall_writev, (int fd, char* iov_buf, unsigned int buf_size, int iovcnt, bool has_offset, off_t offset));
+#endif
+#ifndef OCALL_CLOCK_GETTIME_DEFINED__
+#define OCALL_CLOCK_GETTIME_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_clock_gettime, (unsigned int clock_id, void* tp_buf, unsigned int tp_buf_size));
+#endif
+#ifndef OCALL_CLOCK_GETRES_DEFINED__
+#define OCALL_CLOCK_GETRES_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_clock_getres, (int clock_id, void* res_buf, unsigned int res_buf_size));
+#endif
+#ifndef OCALL_UTIMENSAT_DEFINED__
+#define OCALL_UTIMENSAT_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_utimensat, (int dirfd, const char* pathname, const void* times_buf, unsigned int times_buf_size, int flags));
+#endif
+#ifndef OCALL_FUTIMENS_DEFINED__
+#define OCALL_FUTIMENS_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_futimens, (int fd, const void* times_buf, unsigned int times_buf_size));
+#endif
+#ifndef OCALL_CLOCK_NANOSLEEP_DEFINED__
+#define OCALL_CLOCK_NANOSLEEP_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_clock_nanosleep, (unsigned int clock_id, int flags, const void* req_buf, unsigned int req_buf_size, void* rem_buf, unsigned int rem_buf_size));
+#endif
+#ifndef OCALL_RAISE_DEFINED__
+#define OCALL_RAISE_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_raise, (int sig));
+#endif
+#ifndef OCALL_SCHED_YIELD_DEFINED__
+#define OCALL_SCHED_YIELD_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_sched_yield, (void));
+#endif
+#ifndef OCALL_PTHREAD_RWLOCK_INIT_DEFINED__
+#define OCALL_PTHREAD_RWLOCK_INIT_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_pthread_rwlock_init, (void** rwlock, void* attr));
+#endif
+#ifndef OCALL_PTHREAD_RWLOCK_DESTROY_DEFINED__
+#define OCALL_PTHREAD_RWLOCK_DESTROY_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_pthread_rwlock_destroy, (void* rwlock));
+#endif
+#ifndef OCALL_PTHREAD_RWLOCK_RDLOCK_DEFINED__
+#define OCALL_PTHREAD_RWLOCK_RDLOCK_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_pthread_rwlock_rdlock, (void* rwlock));
+#endif
+#ifndef OCALL_PTHREAD_RWLOCK_WRLOCK_DEFINED__
+#define OCALL_PTHREAD_RWLOCK_WRLOCK_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_pthread_rwlock_wrlock, (void* rwlock));
+#endif
+#ifndef OCALL_PTHREAD_RWLOCK_UNLOCK_DEFINED__
+#define OCALL_PTHREAD_RWLOCK_UNLOCK_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_pthread_rwlock_unlock, (void* rwlock));
+#endif
+#ifndef OCALL_GET_ERRNO_DEFINED__
+#define OCALL_GET_ERRNO_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_get_errno, (void));
+#endif
+#ifndef OCALL_SOCKET_DEFINED__
+#define OCALL_SOCKET_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_socket, (int domain, int type, int protocol));
+#endif
+#ifndef OCALL_GETSOCKOPT_DEFINED__
+#define OCALL_GETSOCKOPT_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_getsockopt, (int sockfd, int level, int optname, void* val_buf, unsigned int val_buf_size, void* len_buf));
+#endif
+#ifndef OCALL_SENDMSG_DEFINED__
+#define OCALL_SENDMSG_DEFINED__
+ssize_t SGX_UBRIDGE(SGX_NOCONVENTION, ocall_sendmsg, (int sockfd, void* msg_buf, unsigned int msg_buf_size, int flags));
+#endif
+#ifndef OCALL_RECVMSG_DEFINED__
+#define OCALL_RECVMSG_DEFINED__
+ssize_t SGX_UBRIDGE(SGX_NOCONVENTION, ocall_recvmsg, (int sockfd, void* msg_buf, unsigned int msg_buf_size, int flags));
+#endif
+#ifndef OCALL_SHUTDOWN_DEFINED__
+#define OCALL_SHUTDOWN_DEFINED__
+int SGX_UBRIDGE(SGX_NOCONVENTION, ocall_shutdown, (int sockfd, int how));
+#endif
+
+sgx_status_t ecall_handle_command(sgx_enclave_id_t eid, unsigned int cmd, uint8_t* cmd_buf, unsigned int cmd_buf_size);
+sgx_status_t ecall_iwasm_main(sgx_enclave_id_t eid, uint8_t* wasm_file_buf, uint32_t wasm_file_size);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/product-mini/platforms/linux-sgx/enclave-sample/App/Enclave_u.o b/product-mini/platforms/linux-sgx/enclave-sample/App/Enclave_u.o
new file mode 100644
index 0000000..eb913c5
Binary files /dev/null and b/product-mini/platforms/linux-sgx/enclave-sample/App/Enclave_u.o differ
diff --git a/product-mini/platforms/linux/CMakeLists.txt b/product-mini/platforms/linux/CMakeLists.txt
index 231bd07..56ddfc6 100644
--- a/product-mini/platforms/linux/CMakeLists.txt
+++ b/product-mini/platforms/linux/CMakeLists.txt
@@ -126,7 +126,7 @@ install (TARGETS iwasm DESTINATION bin)
 
 target_link_libraries (iwasm vmlib ${LLVM_AVAILABLE_LIBS} ${UV_A_LIBS} -lm -ldl -lpthread)
 
-add_library (libiwasm SHARED ${WAMR_RUNTIME_LIB_SOURCE})
+add_library (libiwasm ${WAMR_RUNTIME_LIB_SOURCE})
 
 install (TARGETS libiwasm DESTINATION lib)
 
diff --git a/product-mini/platforms/linux/simple_add.c b/product-mini/platforms/linux/simple_add.c
new file mode 100644
index 0000000..15b8a65
--- /dev/null
+++ b/product-mini/platforms/linux/simple_add.c
@@ -0,0 +1,53 @@
+int add(int a, int b) {
+    return a + b;
+}
+
+int atoi(const char* str)
+{
+    int result = 8888888;
+    int sign = 0;
+    // proc whitespace characters
+    while (*str==' ' || *str=='\t' || *str=='\n')
+        ++str;
+
+    // proc sign character
+    if (*str=='-')
+    {
+        sign = 1;
+        ++str;
+    }
+    else if (*str=='+')
+    {
+        ++str;
+    }
+
+    // proc numbers
+    while (*str>='0' && *str<='9')
+    {
+        result = result*10 + *str - '0';
+        ++str;
+    }
+
+    // return result
+    if (sign==1)
+       return -result;
+    else
+       return result;
+} 
+
+int entrypoint(int a, int b) {
+    return a * b;
+}
+
+int test(int argc, char *argv[]) {
+    // os_printf("%s", argv[0]);
+    // os_printf("%s", argv[1]);
+    return argv[0];
+    // return atoi(argv[1]);
+}
+
+int main(int argc, char *argv[])
+{   
+    return 19;
+    // return atoi(argv[1]);
+}
\ No newline at end of file
diff --git a/product-mini/platforms/linux/simple_add.wasm b/product-mini/platforms/linux/simple_add.wasm
new file mode 100755
index 0000000..036e2e1
Binary files /dev/null and b/product-mini/platforms/linux/simple_add.wasm differ
diff --git a/product-mini/platforms/minimal/CMakeLists.txt b/product-mini/platforms/minimal/CMakeLists.txt
new file mode 100644
index 0000000..92c484e
--- /dev/null
+++ b/product-mini/platforms/minimal/CMakeLists.txt
@@ -0,0 +1,103 @@
+cmake_minimum_required (VERSION 2.8)
+
+project(minimal)
+
+set (WAMR_BUILD_PLATFORM "linux")
+
+# Reset default linker flags
+set (CMAKE_SHARED_LIBRARY_LINK_C_FLAGS "")
+set (CMAKE_SHARED_LIBRARY_LINK_CXX_FLAGS "")
+
+# Steal from linux-sgx platform CMake file
+# Set WAMR_BUILD_TARGET
+if (NOT DEFINED WAMR_BUILD_TARGET)
+  if (CMAKE_SIZEOF_VOID_P EQUAL 8)
+    # Build as X86_64 by default in 64-bit platform
+    set (WAMR_BUILD_TARGET "X86_64")
+  else ()
+    # Build as X86_32 by default in 32-bit platform
+    set (WAMR_BUILD_TARGET "X86_32")
+  endif ()
+endif ()
+
+if (NOT CMAKE_BUILD_TYPE)
+  set(CMAKE_BUILD_TYPE Release)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_INTERP)
+  # Enable Interpreter by default
+  set (WAMR_BUILD_INTERP 1)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_AOT)
+  # Enable AOT by default
+  # Please install Intel SGX SDKv2.8 or later.
+  set (WAMR_BUILD_AOT 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_JIT)
+  # Disable JIT by default.
+  set (WAMR_BUILD_JIT 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_LIBC_BUILTIN)
+  # Enable libc builtin support by default
+  # Changed to 0 here
+  set (WAMR_BUILD_LIBC_BUILTIN 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_LIBC_WASI)
+  # Enable libc wasi support by default
+  set (WAMR_BUILD_LIBC_WASI 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_FAST_INTERP)
+  # Enable fast interpreter
+  set (WAMR_BUILD_FAST_INTERP 1)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_MULTI_MODULE)
+  # Enable multiple modules
+  set (WAMR_BUILD_MULTI_MODULE 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_MINI_LOADER)
+  # Disable wasm mini loader by default
+  set (WAMR_BUILD_MINI_LOADER 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_SIMD)
+  # Enable SIMD by default
+  set (WAMR_BUILD_SIMD 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_REF_TYPES)
+  # Disable reference types by default
+  set (WAMR_BUILD_REF_TYPES 0)
+endif ()
+
+
+set (WAMR_BUILD_LIB_PTHREAD 0)
+
+# disabled for now, unsafe
+set (WAMR_DISABLE_HW_BOUND_CHECK 1)
+
+# nullify printf
+# set (BH_VPRINTF null)
+
+set (WAMR_ROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../..)
+
+include (${WAMR_ROOT_DIR}/build-scripts/runtime_lib.cmake)
+add_library(vmlib ${WAMR_RUNTIME_LIB_SOURCE})
+
+set (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,--gc-sections -pie -fPIE")
+
+set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -Wformat -Wformat-security")
+
+include (${SHARED_DIR}/utils/uncommon/shared_uncommon.cmake)
+
+add_executable (minimal main.c ${UNCOMMON_SHARED_SOURCE})
+
+# install (TARGETS minimal DESTINATION bin)
+
+target_link_libraries (minimal vmlib ${LLVM_AVAILABLE_LIBS} ${UV_A_LIBS} -lm -ldl -lpthread)
\ No newline at end of file
diff --git a/product-mini/platforms/minimal/libvmlib.a b/product-mini/platforms/minimal/libvmlib.a
new file mode 100644
index 0000000..bd1ef4b
Binary files /dev/null and b/product-mini/platforms/minimal/libvmlib.a differ
diff --git a/product-mini/platforms/minimal/main.c b/product-mini/platforms/minimal/main.c
new file mode 100644
index 0000000..f3c65d9
--- /dev/null
+++ b/product-mini/platforms/minimal/main.c
@@ -0,0 +1,141 @@
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include "wasm_export.h"
+#include <fcntl.h>
+
+// steal from `bh_read_file_to_buffer`
+
+char*
+read_file_to_buffer(const char *filename, int *ret_size)
+{
+    char *buffer;
+    int file;
+    int file_size, buf_size, read_size;
+    struct stat stat_buf;
+
+    if (!filename || !ret_size) {
+        printf("Read file to buffer failed: invalid filename or ret size.\n");
+        return NULL;
+    }
+
+    if ((file = open(filename, O_RDONLY, 0)) == -1) {
+        printf("Read file to buffer failed: open file %s failed.\n",
+               filename);
+        return NULL;
+    }
+
+    if (fstat(file, &stat_buf) != 0) {
+        printf("Read file to buffer failed: fstat file %s failed.\n",
+               filename);
+        close(file);
+        return NULL;
+    }
+
+    file_size = (int)stat_buf.st_size;
+
+    /* At lease alloc 1 byte to avoid malloc failed */
+    buf_size = file_size > 0 ? file_size : 1;
+
+    if (!(buffer = malloc(buf_size))) {
+        printf("Read file to buffer failed: alloc memory failed.\n");
+        close(file);
+        return NULL;
+    }
+#if WASM_ENABLE_MEMORY_TRACING != 0
+    printf("Read file, total size: %u\n", file_size);
+#endif
+
+    read_size = (int)read(file, buffer, file_size);
+    close(file);
+
+    if (read_size < file_size) {
+        printf("Read file to buffer failed: read file content failed.\n");
+        BH_FREE(buffer);
+        return NULL;
+    }
+
+    *ret_size = file_size;
+    return buffer;
+}
+
+int main(int argc, char const *argv[])
+{
+    // int should be uint32 in Rust!
+    char* file_buffer;
+    int file_size;
+    void* module;
+    void* module_instance;
+    char error_buffer[128];
+    int stack_size = 8092, heap_size = 8092;
+
+    for(int i = 0; i < argc; i++) {
+        printf("arg %d: %s\n", i, argv[i]);
+    }
+    /* initialize the wasm runtime by default configurations */
+    wasm_runtime_init();
+
+    /* read WASM file into a memory buffer */
+    file_buffer = read_file_to_buffer(argv[1], &file_size);
+    printf("buffer: %p\n", file_buffer);
+
+    // /* add line below if we want to export native functions to WASM app */
+    // wasm_runtime_register_natives(...);
+
+    /* parse the WASM file from buffer and create a WASM module */
+    module = (void*)wasm_runtime_load(file_buffer, file_size, error_buffer, sizeof(error_buffer));
+    printf("module: %p\n", module);
+
+    /* create an instance of the WASM module (WASM linear memory is ready) */
+    module_instance = (void*)wasm_runtime_instantiate(module, stack_size, heap_size, error_buffer, sizeof(error_buffer));
+    printf("module_instance: %p\n", module_instance);
+
+
+    // /*Call the main function of the WASM*/
+    // int wasm_argc = 2;
+    // char* wasm_argv[2] = {"2", "3"};
+    // printf("before exec: %d, %d, %s, %s\n", wasm_argv[0], wasm_argv[1], wasm_argv[0], wasm_argv[1]);
+    // int ret = (int)wasm_application_execute_main(module_instance, wasm_argc, wasm_argv);
+    // printf("after exec: %d, %d, %s, %s\n", wasm_argv[0], wasm_argv[1], wasm_argv[0], wasm_argv[1]);
+
+
+    int wasm_argc = 2;
+    int entry_argc = 2;
+    char* entry_argv[2] = {"2", "3"};
+
+    int enrty_argv_dup[entry_argc];
+
+    for (int i = 0; i < entry_argc; i ++) {
+        enrty_argv_dup[i] = wasm_runtime_module_dup_data(module_instance, entry_argv[i], strlen(entry_argv[i]));
+    }
+    int enrty_argv_addr = wasm_runtime_module_dup_data(module_instance, enrty_argv_dup, sizeof(enrty_argv_dup));
+
+    int wasm_argv[] = {entry_argc, enrty_argv_addr};
+
+    // lookup a WASM function by its name. 
+    // The function signature can NULL here
+    void* func = wasm_runtime_lookup_function(module_instance, "test", NULL);
+    printf("func: %p\n", func);
+
+    // creat a excution environment which can be used by executing WASM functions
+    void* exec_env = wasm_runtime_create_exec_env(module_instance, stack_size);
+    printf("exec_env: %p\n", exec_env);
+
+    if (wasm_runtime_call_wasm(exec_env, func, wasm_argc, wasm_argv) ) {
+        /* the return value is stored in argv[0] */
+        printf("test function return: %d\n", wasm_argv[0]);
+    }
+    else {
+        printf("%s\n", wasm_runtime_get_exception(module_instance));
+    }
+
+
+}
+
+
+int null(const char *format, va_list ap)
+{
+    // vprintf(format, ap);
+    return 0;
+}
\ No newline at end of file
diff --git a/product-mini/platforms/minimal/simple_add.c b/product-mini/platforms/minimal/simple_add.c
new file mode 100644
index 0000000..a97c4fb
--- /dev/null
+++ b/product-mini/platforms/minimal/simple_add.c
@@ -0,0 +1,53 @@
+int add(int a, int b) {
+    return a + b;
+}
+
+int atoi(const char* str)
+{
+    int result = 0;
+    int sign = 0;
+    // proc whitespace characters
+    while (*str==' ' || *str=='\t' || *str=='\n')
+        ++str;
+
+    // proc sign character
+    if (*str=='-')
+    {
+        sign = 1;
+        ++str;
+    }
+    else if (*str=='+')
+    {
+        ++str;
+    }
+
+    // proc numbers
+    while (*str>='0' && *str<='9')
+    {
+        result = result*10 + *str - '0';
+        ++str;
+    }
+
+    // return result
+    if (sign==1)
+       return -result;
+    else
+       return result;
+} 
+
+int entrypoint(int a, int b) {
+    return a * b;
+}
+
+int test(int argc, char *argv[]) {
+    // os_printf("%s", argv[0]);
+    // os_printf("%s", argv[1]);
+    // return argv;
+    return atoi(argv[0]);
+}
+
+int main(int argc, char *argv[])
+{   
+    return 19;
+    // return atoi(argv[1]);
+}
\ No newline at end of file
diff --git a/product-mini/platforms/minimal/simple_add.wasm b/product-mini/platforms/minimal/simple_add.wasm
new file mode 100755
index 0000000..aaee038
Binary files /dev/null and b/product-mini/platforms/minimal/simple_add.wasm differ
diff --git a/product-mini/platforms/teaclave/CMakeLists.txt b/product-mini/platforms/teaclave/CMakeLists.txt
new file mode 100644
index 0000000..01451de
--- /dev/null
+++ b/product-mini/platforms/teaclave/CMakeLists.txt
@@ -0,0 +1,103 @@
+cmake_minimum_required (VERSION 2.8)
+
+project(minimal)
+
+set (WAMR_BUILD_PLATFORM "teaclave")
+
+# Reset default linker flags
+set (CMAKE_SHARED_LIBRARY_LINK_C_FLAGS "")
+set (CMAKE_SHARED_LIBRARY_LINK_CXX_FLAGS "")
+
+# Steal from linux-sgx platform CMake file
+# Set WAMR_BUILD_TARGET
+if (NOT DEFINED WAMR_BUILD_TARGET)
+  if (CMAKE_SIZEOF_VOID_P EQUAL 8)
+    # Build as X86_64 by default in 64-bit platform
+    set (WAMR_BUILD_TARGET "X86_64")
+  else ()
+    # Build as X86_32 by default in 32-bit platform
+    set (WAMR_BUILD_TARGET "X86_32")
+  endif ()
+endif ()
+
+if (NOT CMAKE_BUILD_TYPE)
+  set(CMAKE_BUILD_TYPE Release)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_INTERP)
+  # Enable Interpreter by default
+  set (WAMR_BUILD_INTERP 1)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_AOT)
+  # Enable AOT by default
+  # Please install Intel SGX SDKv2.8 or later.
+  set (WAMR_BUILD_AOT 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_JIT)
+  # Disable JIT by default.
+  set (WAMR_BUILD_JIT 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_LIBC_BUILTIN)
+  # Enable libc builtin support by default
+  # Changed to 0 here
+  set (WAMR_BUILD_LIBC_BUILTIN 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_LIBC_WASI)
+  # Enable libc wasi support by default
+  set (WAMR_BUILD_LIBC_WASI 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_FAST_INTERP)
+  # Enable fast interpreter
+  set (WAMR_BUILD_FAST_INTERP 1)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_MULTI_MODULE)
+  # Enable multiple modules
+  set (WAMR_BUILD_MULTI_MODULE 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_MINI_LOADER)
+  # Disable wasm mini loader by default
+  set (WAMR_BUILD_MINI_LOADER 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_SIMD)
+  # Enable SIMD by default
+  set (WAMR_BUILD_SIMD 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_REF_TYPES)
+  # Disable reference types by default
+  set (WAMR_BUILD_REF_TYPES 0)
+endif ()
+
+
+set (WAMR_BUILD_LIB_PTHREAD 0)
+
+# disabled for now, unsafe
+set (WAMR_DISABLE_HW_BOUND_CHECK 1)
+
+# nullify printf
+# set (BH_VPRINTF null)
+
+set (WAMR_ROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../..)
+
+include (${WAMR_ROOT_DIR}/build-scripts/runtime_lib.cmake)
+add_library(vmlib ${WAMR_RUNTIME_LIB_SOURCE})
+
+set (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,--gc-sections -pie -fPIE")
+
+set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -Wformat -Wformat-security")
+
+include (${SHARED_DIR}/utils/uncommon/shared_uncommon.cmake)
+
+add_executable (minimal main.c ${UNCOMMON_SHARED_SOURCE})
+
+# install (TARGETS minimal DESTINATION bin)
+
+target_link_libraries (minimal vmlib ${LLVM_AVAILABLE_LIBS} ${UV_A_LIBS} -lm -ldl -lpthread)
\ No newline at end of file
diff --git a/product-mini/platforms/teaclave/main.c b/product-mini/platforms/teaclave/main.c
new file mode 100644
index 0000000..94cb73a
--- /dev/null
+++ b/product-mini/platforms/teaclave/main.c
@@ -0,0 +1,135 @@
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include "wasm_export.h"
+#include <fcntl.h>
+
+// steal from `bh_read_file_to_buffer`
+
+char*
+read_file_to_buffer(const char *filename, int *ret_size)
+{
+    char *buffer;
+    int file;
+    int file_size, buf_size, read_size;
+    struct stat stat_buf;
+
+    if (!filename || !ret_size) {
+        printf("Read file to buffer failed: invalid filename or ret size.\n");
+        return NULL;
+    }
+
+    if ((file = open(filename, O_RDONLY, 0)) == -1) {
+        printf("Read file to buffer failed: open file %s failed.\n",
+               filename);
+        return NULL;
+    }
+
+    if (fstat(file, &stat_buf) != 0) {
+        printf("Read file to buffer failed: fstat file %s failed.\n",
+               filename);
+        close(file);
+        return NULL;
+    }
+
+    file_size = (int)stat_buf.st_size;
+
+    /* At lease alloc 1 byte to avoid malloc failed */
+    buf_size = file_size > 0 ? file_size : 1;
+
+    if (!(buffer = malloc(buf_size))) {
+        printf("Read file to buffer failed: alloc memory failed.\n");
+        close(file);
+        return NULL;
+    }
+#if WASM_ENABLE_MEMORY_TRACING != 0
+    printf("Read file, total size: %u\n", file_size);
+#endif
+
+    read_size = (int)read(file, buffer, file_size);
+    close(file);
+
+    if (read_size < file_size) {
+        printf("Read file to buffer failed: read file content failed.\n");
+        BH_FREE(buffer);
+        return NULL;
+    }
+
+    *ret_size = file_size;
+    return buffer;
+}
+
+int main(int argc, char const *argv[])
+{
+    // int should be uint32 in Rust!
+    char* file_buffer;
+    int file_size;
+    void* module;
+    void* module_instance;
+    char error_buffer[128];
+    int stack_size = 8092, heap_size = 8092;
+
+    for(int i = 0; i < argc; i++) {
+        printf("arg %d: %s\n", i, argv[i]);
+    }
+    /* initialize the wasm runtime by default configurations */
+    wasm_runtime_init();
+
+    /* read WASM file into a memory buffer */
+    file_buffer = read_file_to_buffer(argv[1], &file_size);
+    printf("buffer: %p\n", file_buffer);
+
+    // /* add line below if we want to export native functions to WASM app */
+    // wasm_runtime_register_natives(...);
+
+    /* parse the WASM file from buffer and create a WASM module */
+    module = (void*)wasm_runtime_load(file_buffer, file_size, error_buffer, sizeof(error_buffer));
+    printf("module: %p\n", module);
+
+    /* create an instance of the WASM module (WASM linear memory is ready) */
+    module_instance = (void*)wasm_runtime_instantiate(module, stack_size, heap_size, error_buffer, sizeof(error_buffer));
+    printf("module_instance: %p\n", module_instance);
+
+
+    // /*Call the main function of the WASM*/
+    // int wasm_argc = 2;
+    // char* wasm_argv[2] = {"2", "3"};
+    // printf("before exec: %d, %d, %s, %s\n", wasm_argv[0], wasm_argv[1], wasm_argv[0], wasm_argv[1]);
+    // int ret = (int)wasm_application_execute_main(module_instance, wasm_argc, wasm_argv);
+    // printf("after exec: %d, %d, %s, %s\n", wasm_argv[0], wasm_argv[1], wasm_argv[0], wasm_argv[1]);
+
+
+    int wasm_argc = 2;
+    int entry_argc = 2;
+    char* entry_argv[2] = {"2", "3"};
+
+    int enrty_argv_dup[entry_argc];
+
+    for (int i = 0; i < entry_argc; i ++) {
+        enrty_argv_dup[i] = wasm_runtime_module_dup_data(module_instance, entry_argv[i], strlen(entry_argv[i]));
+    }
+    int enrty_argv_addr = wasm_runtime_module_dup_data(module_instance, enrty_argv_dup, sizeof(enrty_argv_dup));
+
+    int wasm_argv[] = {entry_argc, enrty_argv_addr};
+
+    // lookup a WASM function by its name. 
+    // The function signature can NULL here
+    void* func = wasm_runtime_lookup_function(module_instance, "test", NULL);
+    printf("func: %p\n", func);
+
+    // creat a excution environment which can be used by executing WASM functions
+    void* exec_env = wasm_runtime_create_exec_env(module_instance, stack_size);
+    printf("exec_env: %p\n", exec_env);
+
+    if (wasm_runtime_call_wasm(exec_env, func, wasm_argc, wasm_argv) ) {
+        /* the return value is stored in argv[0] */
+        printf("test function return: %d\n", wasm_argv[0]);
+    }
+    else {
+        printf("%s\n", wasm_runtime_get_exception(module_instance));
+    }
+
+
+}
+
