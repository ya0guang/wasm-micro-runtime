diff --git a/core/shared/platform/common/posix/posix_thread.c b/core/shared/platform/common/posix/posix_thread.c
index 60a13fb..ce0b8ad 100644
--- a/core/shared/platform/common/posix/posix_thread.c
+++ b/core/shared/platform/common/posix/posix_thread.c
@@ -544,4 +544,3 @@ os_sigreturn()
 #endif
 }
 #endif /* end of OS_ENABLE_HW_BOUND_CHECK */
-
diff --git a/core/shared/platform/teaclave/platform_internal.h b/core/shared/platform/teaclave/platform_internal.h
new file mode 100644
index 0000000..83a08f4
--- /dev/null
+++ b/core/shared/platform/teaclave/platform_internal.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2019 Intel Corporation.  All rights reserved.
+ * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+ */
+
+#ifndef _PLATFORM_INTERNAL_H
+#define _PLATFORM_INTERNAL_H
+
+#include <inttypes.h>
+#include <stdbool.h>
+#include <assert.h>
+#include <time.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <stdarg.h>
+#include <ctype.h>
+#include <pthread.h>
+#include <signal.h>
+#include <semaphore.h>
+#include <limits.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <poll.h>
+#include <sched.h>
+#include <errno.h>
+#include <netinet/in.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+#include <sys/timeb.h>
+#include <sys/uio.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/resource.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef BH_PLATFORM_TEACLAVE
+#define BH_PLATFORM_TEACLAVE
+#endif
+
+/* Stack size of applet threads's native part.  */
+#define BH_APPLET_PRESERVED_STACK_SIZE (32 * 1024)
+
+/* Default thread priority */
+#define BH_THREAD_DEFAULT_PRIORITY 0
+// #define os_thread_get_stack_boundary null
+
+typedef pthread_t korp_tid;
+typedef pthread_mutex_t korp_mutex;
+typedef pthread_cond_t korp_cond;
+typedef pthread_t korp_thread;
+
+#define os_thread_local_attribute __thread
+
+#if WASM_DISABLE_HW_BOUND_CHECK == 0
+#if defined(BUILD_TARGET_X86_64) \
+    || defined(BUILD_TARGET_AMD_64) \
+    || defined(BUILD_TARGET_AARCH64)
+
+#include <setjmp.h>
+
+#define OS_ENABLE_HW_BOUND_CHECK
+
+typedef jmp_buf korp_jmpbuf;
+
+#define os_setjmp setjmp
+#define os_longjmp longjmp
+#define os_alloca alloca
+
+#define os_getpagesize getpagesize
+
+typedef void (*os_signal_handler)(void *sig_addr);
+
+int os_thread_signal_init(os_signal_handler handler);
+
+void os_thread_signal_destroy();
+
+bool os_thread_signal_inited();
+
+void os_signal_unmask();
+
+void os_sigreturn();
+#endif /* end of BUILD_TARGET_X86_64/AMD_64/AARCH64 */
+#endif /* end of WASM_DISABLE_HW_BOUND_CHECK */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of _PLATFORM_INTERNAL_H */
+
diff --git a/core/shared/platform/teaclave/shared_platform.cmake b/core/shared/platform/teaclave/shared_platform.cmake
new file mode 100644
index 0000000..0b8e32a
--- /dev/null
+++ b/core/shared/platform/teaclave/shared_platform.cmake
@@ -0,0 +1,16 @@
+# Copyright (C) 2019 Intel Corporation.  All rights reserved.
+# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+
+set (PLATFORM_SHARED_DIR ${CMAKE_CURRENT_LIST_DIR})
+
+add_definitions(-DBH_PLATFORM_TEACLAVE)
+
+include_directories(${PLATFORM_SHARED_DIR})
+include_directories(${PLATFORM_SHARED_DIR}/../include)
+
+file (GLOB_RECURSE source_all ${PLATFORM_SHARED_DIR}/*.c)
+
+set (PLATFORM_SHARED_SOURCE ${source_all} ${PLATFORM_COMMON_POSIX_SOURCE})
+
+file (GLOB header ${PLATFORM_SHARED_DIR}/../include/*.h)
+LIST (APPEND RUNTIME_LIB_HEADER_LIST ${header})
diff --git a/core/shared/platform/teaclave/teaclave_platform.c b/core/shared/platform/teaclave/teaclave_platform.c
new file mode 100644
index 0000000..297c862
--- /dev/null
+++ b/core/shared/platform/teaclave/teaclave_platform.c
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2019 Intel Corporation.  All rights reserved.
+ * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+ */
+
+#include "platform_api_vmcore.h"
+#include <platform_api_vmcore.h>
+#include <platform_api_extension.h>
+
+int
+bh_platform_init()
+{
+    return 0;
+}
+
+void
+bh_platform_destroy()
+{
+}
+
+int
+os_printf(const char *format, ...)
+{
+    int ret = 0;
+    va_list ap;
+
+    va_start(ap, format);
+#ifndef BH_VPRINTF
+    // ya0guang: also nullify here
+    return NULL;
+    // ret += vprintf(format, ap);
+#else
+    ret += BH_VPRINTF(format, ap);
+#endif
+    va_end(ap);
+
+    return ret;
+}
+
+int
+os_vprintf(const char *format, va_list ap)
+{
+#ifndef BH_VPRINTF
+    // ya0guang: nullify printf
+    return 0;
+    // return vprintf(format, ap);
+#else
+    return BH_VPRINTF(format, ap);
+#endif
+}
+
+// ya0guang: nullify this implementation 
+uint8 *os_thread_get_stack_boundary(void)
+{
+    return NULL;
+}
+
+// functions below are copied from the common library
+
+void *
+os_malloc(unsigned size)
+{
+    return malloc(size);
+}
+
+void *
+os_realloc(void *ptr, unsigned size)
+{
+    return realloc(ptr, size);
+}
+
+void
+os_free(void *ptr)
+{
+    free(ptr);
+}
+
+int os_mutex_destroy(korp_mutex *mutex)
+{
+    int ret;
+
+    assert(mutex);
+    ret = pthread_mutex_destroy(mutex);
+
+    return ret == 0 ? BHT_OK : BHT_ERROR;
+}
+
+
+int os_mutex_unlock(korp_mutex *mutex)
+{
+    int ret;
+
+    assert(mutex);
+    ret = pthread_mutex_unlock(mutex);
+
+    return ret == 0 ? BHT_OK : BHT_ERROR;
+}
+
+int os_mutex_lock(korp_mutex *mutex)
+{
+    int ret;
+
+    assert(mutex);
+    ret = pthread_mutex_lock(mutex);
+
+    return ret == 0 ? BHT_OK : BHT_ERROR;
+}
+
+int os_mutex_init(korp_mutex *mutex)
+{
+    return pthread_mutex_init(mutex, NULL) == 0 ? BHT_OK : BHT_ERROR;
+}
+
+uint64
+os_time_get_boot_microsecond()
+{
+    struct timespec ts;
+    if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0) {
+        return 0;
+    }
+
+    return ((uint64) ts.tv_sec) * 1000 * 1000 + ((uint64)ts.tv_nsec) / 1000;
+}
+
+
+korp_tid os_self_thread()
+{
+    return (korp_tid) pthread_self();
+}
\ No newline at end of file
diff --git a/product-mini/platforms/teaclave/CMakeLists.txt b/product-mini/platforms/teaclave/CMakeLists.txt
new file mode 100644
index 0000000..01451de
--- /dev/null
+++ b/product-mini/platforms/teaclave/CMakeLists.txt
@@ -0,0 +1,103 @@
+cmake_minimum_required (VERSION 2.8)
+
+project(minimal)
+
+set (WAMR_BUILD_PLATFORM "teaclave")
+
+# Reset default linker flags
+set (CMAKE_SHARED_LIBRARY_LINK_C_FLAGS "")
+set (CMAKE_SHARED_LIBRARY_LINK_CXX_FLAGS "")
+
+# Steal from linux-sgx platform CMake file
+# Set WAMR_BUILD_TARGET
+if (NOT DEFINED WAMR_BUILD_TARGET)
+  if (CMAKE_SIZEOF_VOID_P EQUAL 8)
+    # Build as X86_64 by default in 64-bit platform
+    set (WAMR_BUILD_TARGET "X86_64")
+  else ()
+    # Build as X86_32 by default in 32-bit platform
+    set (WAMR_BUILD_TARGET "X86_32")
+  endif ()
+endif ()
+
+if (NOT CMAKE_BUILD_TYPE)
+  set(CMAKE_BUILD_TYPE Release)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_INTERP)
+  # Enable Interpreter by default
+  set (WAMR_BUILD_INTERP 1)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_AOT)
+  # Enable AOT by default
+  # Please install Intel SGX SDKv2.8 or later.
+  set (WAMR_BUILD_AOT 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_JIT)
+  # Disable JIT by default.
+  set (WAMR_BUILD_JIT 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_LIBC_BUILTIN)
+  # Enable libc builtin support by default
+  # Changed to 0 here
+  set (WAMR_BUILD_LIBC_BUILTIN 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_LIBC_WASI)
+  # Enable libc wasi support by default
+  set (WAMR_BUILD_LIBC_WASI 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_FAST_INTERP)
+  # Enable fast interpreter
+  set (WAMR_BUILD_FAST_INTERP 1)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_MULTI_MODULE)
+  # Enable multiple modules
+  set (WAMR_BUILD_MULTI_MODULE 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_MINI_LOADER)
+  # Disable wasm mini loader by default
+  set (WAMR_BUILD_MINI_LOADER 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_SIMD)
+  # Enable SIMD by default
+  set (WAMR_BUILD_SIMD 0)
+endif ()
+
+if (NOT DEFINED WAMR_BUILD_REF_TYPES)
+  # Disable reference types by default
+  set (WAMR_BUILD_REF_TYPES 0)
+endif ()
+
+
+set (WAMR_BUILD_LIB_PTHREAD 0)
+
+# disabled for now, unsafe
+set (WAMR_DISABLE_HW_BOUND_CHECK 1)
+
+# nullify printf
+# set (BH_VPRINTF null)
+
+set (WAMR_ROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../..)
+
+include (${WAMR_ROOT_DIR}/build-scripts/runtime_lib.cmake)
+add_library(vmlib ${WAMR_RUNTIME_LIB_SOURCE})
+
+set (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,--gc-sections -pie -fPIE")
+
+set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -Wformat -Wformat-security")
+
+include (${SHARED_DIR}/utils/uncommon/shared_uncommon.cmake)
+
+add_executable (minimal main.c ${UNCOMMON_SHARED_SOURCE})
+
+# install (TARGETS minimal DESTINATION bin)
+
+target_link_libraries (minimal vmlib ${LLVM_AVAILABLE_LIBS} ${UV_A_LIBS} -lm -ldl -lpthread)
\ No newline at end of file
diff --git a/product-mini/platforms/teaclave/main.c b/product-mini/platforms/teaclave/main.c
new file mode 100644
index 0000000..94cb73a
--- /dev/null
+++ b/product-mini/platforms/teaclave/main.c
@@ -0,0 +1,135 @@
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include "wasm_export.h"
+#include <fcntl.h>
+
+// steal from `bh_read_file_to_buffer`
+
+char*
+read_file_to_buffer(const char *filename, int *ret_size)
+{
+    char *buffer;
+    int file;
+    int file_size, buf_size, read_size;
+    struct stat stat_buf;
+
+    if (!filename || !ret_size) {
+        printf("Read file to buffer failed: invalid filename or ret size.\n");
+        return NULL;
+    }
+
+    if ((file = open(filename, O_RDONLY, 0)) == -1) {
+        printf("Read file to buffer failed: open file %s failed.\n",
+               filename);
+        return NULL;
+    }
+
+    if (fstat(file, &stat_buf) != 0) {
+        printf("Read file to buffer failed: fstat file %s failed.\n",
+               filename);
+        close(file);
+        return NULL;
+    }
+
+    file_size = (int)stat_buf.st_size;
+
+    /* At lease alloc 1 byte to avoid malloc failed */
+    buf_size = file_size > 0 ? file_size : 1;
+
+    if (!(buffer = malloc(buf_size))) {
+        printf("Read file to buffer failed: alloc memory failed.\n");
+        close(file);
+        return NULL;
+    }
+#if WASM_ENABLE_MEMORY_TRACING != 0
+    printf("Read file, total size: %u\n", file_size);
+#endif
+
+    read_size = (int)read(file, buffer, file_size);
+    close(file);
+
+    if (read_size < file_size) {
+        printf("Read file to buffer failed: read file content failed.\n");
+        BH_FREE(buffer);
+        return NULL;
+    }
+
+    *ret_size = file_size;
+    return buffer;
+}
+
+int main(int argc, char const *argv[])
+{
+    // int should be uint32 in Rust!
+    char* file_buffer;
+    int file_size;
+    void* module;
+    void* module_instance;
+    char error_buffer[128];
+    int stack_size = 8092, heap_size = 8092;
+
+    for(int i = 0; i < argc; i++) {
+        printf("arg %d: %s\n", i, argv[i]);
+    }
+    /* initialize the wasm runtime by default configurations */
+    wasm_runtime_init();
+
+    /* read WASM file into a memory buffer */
+    file_buffer = read_file_to_buffer(argv[1], &file_size);
+    printf("buffer: %p\n", file_buffer);
+
+    // /* add line below if we want to export native functions to WASM app */
+    // wasm_runtime_register_natives(...);
+
+    /* parse the WASM file from buffer and create a WASM module */
+    module = (void*)wasm_runtime_load(file_buffer, file_size, error_buffer, sizeof(error_buffer));
+    printf("module: %p\n", module);
+
+    /* create an instance of the WASM module (WASM linear memory is ready) */
+    module_instance = (void*)wasm_runtime_instantiate(module, stack_size, heap_size, error_buffer, sizeof(error_buffer));
+    printf("module_instance: %p\n", module_instance);
+
+
+    // /*Call the main function of the WASM*/
+    // int wasm_argc = 2;
+    // char* wasm_argv[2] = {"2", "3"};
+    // printf("before exec: %d, %d, %s, %s\n", wasm_argv[0], wasm_argv[1], wasm_argv[0], wasm_argv[1]);
+    // int ret = (int)wasm_application_execute_main(module_instance, wasm_argc, wasm_argv);
+    // printf("after exec: %d, %d, %s, %s\n", wasm_argv[0], wasm_argv[1], wasm_argv[0], wasm_argv[1]);
+
+
+    int wasm_argc = 2;
+    int entry_argc = 2;
+    char* entry_argv[2] = {"2", "3"};
+
+    int enrty_argv_dup[entry_argc];
+
+    for (int i = 0; i < entry_argc; i ++) {
+        enrty_argv_dup[i] = wasm_runtime_module_dup_data(module_instance, entry_argv[i], strlen(entry_argv[i]));
+    }
+    int enrty_argv_addr = wasm_runtime_module_dup_data(module_instance, enrty_argv_dup, sizeof(enrty_argv_dup));
+
+    int wasm_argv[] = {entry_argc, enrty_argv_addr};
+
+    // lookup a WASM function by its name. 
+    // The function signature can NULL here
+    void* func = wasm_runtime_lookup_function(module_instance, "test", NULL);
+    printf("func: %p\n", func);
+
+    // creat a excution environment which can be used by executing WASM functions
+    void* exec_env = wasm_runtime_create_exec_env(module_instance, stack_size);
+    printf("exec_env: %p\n", exec_env);
+
+    if (wasm_runtime_call_wasm(exec_env, func, wasm_argc, wasm_argv) ) {
+        /* the return value is stored in argv[0] */
+        printf("test function return: %d\n", wasm_argv[0]);
+    }
+    else {
+        printf("%s\n", wasm_runtime_get_exception(module_instance));
+    }
+
+
+}
+
diff --git a/product-mini/platforms/teaclave/simple_add.c b/product-mini/platforms/teaclave/simple_add.c
new file mode 100644
index 0000000..a97c4fb
--- /dev/null
+++ b/product-mini/platforms/teaclave/simple_add.c
@@ -0,0 +1,53 @@
+int add(int a, int b) {
+    return a + b;
+}
+
+int atoi(const char* str)
+{
+    int result = 0;
+    int sign = 0;
+    // proc whitespace characters
+    while (*str==' ' || *str=='\t' || *str=='\n')
+        ++str;
+
+    // proc sign character
+    if (*str=='-')
+    {
+        sign = 1;
+        ++str;
+    }
+    else if (*str=='+')
+    {
+        ++str;
+    }
+
+    // proc numbers
+    while (*str>='0' && *str<='9')
+    {
+        result = result*10 + *str - '0';
+        ++str;
+    }
+
+    // return result
+    if (sign==1)
+       return -result;
+    else
+       return result;
+} 
+
+int entrypoint(int a, int b) {
+    return a * b;
+}
+
+int test(int argc, char *argv[]) {
+    // os_printf("%s", argv[0]);
+    // os_printf("%s", argv[1]);
+    // return argv;
+    return atoi(argv[0]);
+}
+
+int main(int argc, char *argv[])
+{   
+    return 19;
+    // return atoi(argv[1]);
+}
\ No newline at end of file
